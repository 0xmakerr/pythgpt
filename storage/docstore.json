{"docstore/metadata": {"733edcd7-b46c-431b-b60f-281d6da85dc6": {"doc_hash": "b502dc39ea11905529f6e2f909437e199cecb956e10b00ed70d52fd2e3ab7430"}, "30b68589-8f48-4b65-a859-6fd104de5cbb": {"doc_hash": "71810689cf6a916295a1de0484adbf51b2ed2623cc091bd4fc98d928201ec32b"}, "6218bb9b-73d8-4850-9f6f-dd5196c0068c": {"doc_hash": "3af7e69ee2aab8c1c5d66dbffb68792983c77dd67df7d91fbde2ffc7e708a8c6"}, "f28aa417-b07f-486c-a511-3f9a43761b6b": {"doc_hash": "9d320b7423fdf9c792c11623cd867a4b4b46694386685d0148bec06c303ac188"}, "045752ab-dfa7-4e4e-802d-b494c34ec553": {"doc_hash": "de512c1171660edf538681c235d030088e3554939171ec0a452a29bbd74760ac"}, "6d66ba0d-47e8-4d92-b1b6-1b47f88d1954": {"doc_hash": "583a6c6c26443263cb2773cde4426748d812e2c42dfbdaefcae38c67899a12f5"}, "e35bb485-9070-4e17-8883-d1bb2007e2b8": {"doc_hash": "70dc69db9fcb4a43099976fd445a70ce0c4a236f860043109359d27bd391665c"}, "3e6cd561-8e19-4f41-9f34-d6762d0882f7": {"doc_hash": "ffce69619cac905ca4a58ecbe11d41e0af041443448601d939c883c7d6423895"}, "ec90b780-21f8-40a1-9dc3-47b76b55077b": {"doc_hash": "735f54d4c9d98264956dde41368a072a0cf27137e2d03753c70491ec0ba6d49b"}, "395afdac-f424-4295-9066-ef4ca496a153": {"doc_hash": "3f02bd9217aa1dcc7b8602d4cebbde00c3b4fb8b1c978027f1aba0b9c76e0b1a"}, "497414cb-33fa-4e5f-ad0a-6a1550e444b9": {"doc_hash": "7ce3a5ce6a47199c7d31fbc210b56602b0141b468e5e555c2b45030162a5a97e"}, "dbbe853b-db39-4fe2-92c2-fc1b7102dc72": {"doc_hash": "2801853c10a516866a92bf0fea5b33f13c8f8835bb198de3f19ed000d589a04c"}, "dc735726-178c-4cf1-8662-3edbb0475973": {"doc_hash": "2eb960d08f1e8bec2a9025d1e10ef50f0f104b9e9f68044fca30e069d580d370"}, "091bce92-cf5b-4ebc-8c3f-78711a002e0d": {"doc_hash": "a6cfbf783111d2050fb86778cbc0616e636bddf0183865fd7e52ac9ade7d473d"}, "e7f96c59-7448-428f-a058-d7554f958759": {"doc_hash": "93bcc736934bd3048ef522f4b5f63392af1b942d5ef3bbe820a479b6d585b01c"}, "1c7f0335-a0e9-4818-ac92-c0afdbe56d82": {"doc_hash": "6fe23a6001bc60869b7482c2f8568b8845c868e3c14a2125deeadc07021a0317"}, "76ebd27e-30cc-4ac6-822c-1d09cf20f1fb": {"doc_hash": "2309f88e37698671bb7b6e4347e01d0523075efd3cf01bec81df95163a445ba3"}, "af034d0a-df35-4ca7-ab54-cc1d6b0c96b0": {"doc_hash": "6e8bee0157c75a6c5a240ecd628e5dee1ece056caed1142e19bf167ad7dde817"}, "36cbf504-e155-454a-84db-f6aa672a4d97": {"doc_hash": "629e4bcffab80bf3bc2a2d80c1c5f85e99b2b6cf7ab9395fa584fdbc12b9413d"}, "d9221246-58c7-4715-8469-6fd0943fd3a7": {"doc_hash": "42e2f3a90e1b5aac283423b6fe6062735eb51cc92b7fec599f4e90aef56f77cb"}, "0064fcec-49eb-41c7-a186-d51a25bf0c27": {"doc_hash": "052e6a8eea7dbf6b937ca956c19b83d962ec8ed3b58c44b49f27ce194099dafb"}, "aff9ae8a-438d-4250-9f8e-e909ac29e855": {"doc_hash": "8da20c4c46ad83afe34e185fcfd98ee7b4480ce9f53728834f5045f5465bf300"}, "28058ec8-d0f4-4543-981f-af8ff857355f": {"doc_hash": "9b4d86921334b65c34c81e088006de8bbd7c6e56b09e5da690404fef9afb48ff"}, "92578429-7931-4b0b-be3f-bddbb73b492e": {"doc_hash": "3afbb249d608b390d9190872b8f27f97e78092708488aa8f8c58a3df17ed6a46"}, "ee37f4fc-62f2-4bcc-9b18-0ec6f0416c5b": {"doc_hash": "35fffb1cc4c5e66724ab23041cafe210ae77c22364a3c07478b0b5faa477bc1c"}, "1a642690-1439-47fe-a96f-08f0fd23f841": {"doc_hash": "0da6c10a02e46af4ec52a368eae49c0c622762e83bf1021417837bb257fecf57"}, "75a88da7-58fa-489e-aecc-a4dc0f73a898": {"doc_hash": "43f7c544251a371a8bf5137305ae20398a8372bb97dc33ea18b2c9480b51cc21"}, "dcbd169d-4896-435e-a624-2e4e4495cdc0": {"doc_hash": "f3fa3c15e6733ebb67b8ac93653a7e9fe57b7af21c8dbcaee2f1f3a7ad33f26d"}, "99f18e0f-d183-448f-bd78-2e6a1d9c7276": {"doc_hash": "83b2e361dfb515b16ff53ab212aca9365c805db844c9a589899a0045a44c1bbd"}, "838dcec2-2964-4c54-81d4-81a4cd6aca9a": {"doc_hash": "0033494b871fd0c439363a946db286345fdca5bfc356af66f647cd20f80de746"}, "cc79ba93-1ec7-4bc7-8e0c-8ac1ca28a73a": {"doc_hash": "d87b7e4dd344f340b403d9d1340341698f1bf6ff0a9d758dda32464162c9f2e3"}, "17e64f39-75b6-4ce5-8c48-02a7e74597c1": {"doc_hash": "6848c7f119ebaed4523216633deaad18b3f661b186ec61759204222ef2f4db80"}, "5fa0a9ae-5171-4a8b-a4b8-fe6018aab318": {"doc_hash": "1fcf652bf2e7e4e1e9b62561294940e52c82a98a633e114cf2afef890c0d5b32"}, "aa195a20-6c42-4962-8251-2e8e07339ddb": {"doc_hash": "17b6389fac341ea103ee29b043030e21d95d2a4225d21893a8bcaf2fc6b823da"}, "e617588c-37bb-479c-adde-3554e85c5b02": {"doc_hash": "3815b259eb716c06e49fe39ef79c2b356541b67fb0b1c2ef2a50e69bca25eb9a"}, "d1e42746-e062-4e35-bfa9-587191dab8c6": {"doc_hash": "3537992c7130c306bbdce6fd441a3626c2679ed7481857eb5a4babd826a3a67d"}, "fba4ffae-ef70-46a9-8a93-e3eb58a6d81b": {"doc_hash": "a9f72d47c3878794d6ec315d306d310676fb1561741728e15bdc1c56fc4c87fc"}, "aa163b6f-86af-45ec-9687-40e2a25d5020": {"doc_hash": "b11a8a7413ecf1451fce02fcf43dec1b71d919663262eb2c84a5aac0976ec7cb"}, "fadaf1d9-30e5-4131-aba4-30c9cbb2111d": {"doc_hash": "e2e78d1b05f5fd8cd4c77d60de99150b7993b389a81baae353592f086eddb075"}, "80236cbc-10c1-4400-91ab-6ce0b2b42e18": {"doc_hash": "696ad9cfb02f2509d6da8d7f3302f29ab2229b8e8dc7005d22d35e49f2648182"}, "b90c93b6-3826-4f4d-ac89-15d0c185651d": {"doc_hash": "632028c6284243c5b59285a98160bd23d2f609c25ed676b30e276a1ac823bf94"}, "082929e3-9ddb-483a-9176-0262053f108b": {"doc_hash": "ffd3caa92c11f459ae5fa6915861135e02af7fa335f2acfa0a7ed0d7dc4921ba"}, "09b0d1da-a63f-429b-8c9d-497a387df3a5": {"doc_hash": "2aea75dffd971175936e1a3de5f2e72871f3b8580fb501b9148e38d0cd2d28c0"}, "fe2f781c-d5d9-4740-8f15-de2884c23b82": {"doc_hash": "a47935b6ad121cea8adcdf14f8548be5273029d4c3caf27e3893dd4777c49c4a"}, "250f0d04-b83d-4aa2-acb8-994b377d5c22": {"doc_hash": "82f4e7083630786a6adc44a09fe3ff9aa3eaa136f29de80fae87e8078ce25b93"}, "bb5c5c3f-a708-4802-bf73-de1b66cad1dc": {"doc_hash": "1bf0c6b0512c8288705ddd4e2849d47e616437aa6a5cb3ecf0a000df57f410ce"}, "1037f5d7-eb09-4b7d-a13f-46b456441ab0": {"doc_hash": "f79bc9737a629fb0a717e8eefa04323f42b4faf414d8800e46374f329d91c76e"}, "7b67bb4d-f238-431d-9e9e-0c1b933a5fe8": {"doc_hash": "eda0bfa8cc3fdfbfa0e4c3356bec95a5459b2c5a9e22aaf11688341621a4231b"}, "e98fca98-9ddb-4de8-87ad-c0ac568c230f": {"doc_hash": "9c68c346c8f5637aadd6d6608eef28c31a299424bcee97be63e1c5aa451e41a3"}, "bbc38de6-46b1-4e33-8d86-59b4dad6b060": {"doc_hash": "815ca8baa8ba0c8959cd10c51a0f9f45887233c4140f6683255b70fae5a84d95"}, "aa813a62-601b-4083-96bb-3c7093ae99b7": {"doc_hash": "3c430f6c3b975ecd1bb41cdd81bb1ae533f29177e147c6666090a4a4f8e7a8ac"}, "e29c0ba1-45c5-4563-b96e-5bf550470a35": {"doc_hash": "0bd242d037de44eece742f1f162441f84cb206b1a6a7e1c4932bba762f020e8e"}, "ca02e6c2-04fb-42bb-8f0b-8d7b5a00160d": {"doc_hash": "0b6db9242151633cdb59aee89b69349a96d03b940561b714dcfd39a9ffb07ca7"}, "013ffed8-91d4-419c-9b63-3cdd0addc827": {"doc_hash": "b77dc17b77af144d06ee27679961515f4f0b9bb23c2e27bfc94f7188b0e832f4"}, "23324207-911e-477a-b361-8f3bc2f676dd": {"doc_hash": "749ffe0ff0edd3ba4a2757cbb80a783384ded1b1b3e78be3ab30b8e0aac415e9"}, "5d8183f4-642d-45f2-8854-9f06d3bac85a": {"doc_hash": "99b45b9d02ec751ee4aa72270f9797b059b3d6ac63998ad3a53b2509c8247b5f"}, "e8ac8239-ba47-4459-88ca-f706b730d2ed": {"doc_hash": "55dfc5134b400000c196d7552482e195f0d810fca13d1a1cbafff7a17bc07353"}, "060803e8-91f4-4541-a7e8-60250a4c70a4": {"doc_hash": "dd5c246c1c314fc23947ae15d8c28f9ee0ebe2939b255aaada7df689b97821a5"}, "e36fbe1c-9094-4b53-9bff-b5163ddbc739": {"doc_hash": "ed4b12d976d3a1a13c6c28a5fc5d7e227d95d7eaf5332e51fc2e37a5b294df96"}, "afee92ad-e024-41b6-8cd3-3e0ffed148ae": {"doc_hash": "ab61d1fcab7a3c716384e56623b233d65dd57a428de1b2a688f22cd26d928e32"}, "41002785-c66f-41d4-aa4c-417da94dc5ae": {"doc_hash": "ec590efc1c5f11b8ec5331d459a5b233f6f021c1f923cc0e5034817c5b37c5a4"}, "8f9bddbd-80ff-4173-a15a-2bdefb33422e": {"doc_hash": "ad434b70c9bb5bdd73a8e23fa73fac17d65fd3409a3dedfefb126de7bce2c6c9"}, "4fd5078f-f0c8-47d5-9258-849631610897": {"doc_hash": "2bcfb04865007f8bee9062b252731498f37cc0a54fdc02401a37d7c0e55c8ae8"}, "341cac73-f258-4234-a223-c20f83123730": {"doc_hash": "69c14959caf11531d38df45b27b893f85460b68fe1460d888f36e3e704fe7c1c"}, "31bfb2f7-0539-47dd-b99a-cc206e4da6e1": {"doc_hash": "5cb2cbad24d0c5159430c07b2d9691a704309af3cdbaf15eb76f0a478143f667"}, "03a7ddd0-208d-49c2-a438-29177d70ff75": {"doc_hash": "7f19f3eb5966d505980636d1100e04b2150f73a0da737ace2fa0e33633189e3d"}, "8f608bcd-4d1a-4481-96e4-3a49e3a65a38": {"doc_hash": "bda5ca074f6a92da140ec31393aa0ba45a08fe04938d08ee65338d07216e304c"}, "84857449-6650-4741-ac5b-0711508b8a5c": {"doc_hash": "9d320b7423fdf9c792c11623cd867a4b4b46694386685d0148bec06c303ac188"}, "19cdbe59-617e-4906-a1d4-02103ed75e10": {"doc_hash": "de512c1171660edf538681c235d030088e3554939171ec0a452a29bbd74760ac"}, "e2366871-23de-49de-9733-872cc99b675a": {"doc_hash": "925cc37a268502b47f74602a9def0d70282266a9641c25f809430c95ded6ac76"}, "778ed795-0164-4a89-a15a-803e29e8a4b0": {"doc_hash": "894d5e4c2a022fa7ab4595b02bc9245d0726162f693f873b1b40ea6c55f16900"}, "fe4cb3c8-8442-433a-81a0-60a646d91412": {"doc_hash": "70dc69db9fcb4a43099976fd445a70ce0c4a236f860043109359d27bd391665c"}, "d6f2127b-7906-4378-b7af-d19e27fa2f84": {"doc_hash": "10cab5e7bfa1015928b42f7f953886e48ea41945d3c00ab581db0aa4d5f93912"}, "ee0fbd82-8dac-4c96-9d89-adee38f850f9": {"doc_hash": "aeae3cabb17f0213339674b603e25a8adf475008f0cc427bd0f71c202ba99df0"}, "9e9fa8c6-dc0c-4299-8679-63ee3005ee72": {"doc_hash": "648fcb8e913c02739dd566477298b2a9206e6c4b1bf2536081c1d8852e405661"}, "ce20ff79-db06-4103-b701-cf3b202a1dca": {"doc_hash": "af6f7919913cbcf047529621bdfe78985c6150f173991dff26be46f27e21b0e8"}, "78c6a6a1-b17c-464a-9859-f91e1826651f": {"doc_hash": "3f02bd9217aa1dcc7b8602d4cebbde00c3b4fb8b1c978027f1aba0b9c76e0b1a"}, "dfb0c32c-f098-47fe-9f04-141f1a68a25b": {"doc_hash": "1734ba15d810a5c23d343085474ef07d6f7c1f4b7a52fe9d2ae187474c5357d6"}, "a82882a4-37f4-4f61-9463-a1ecc624ee2f": {"doc_hash": "433dfa5671d8d6c5485a7dcb37c01823730f6d7c7f6d5394dcf9536d45fe4309"}, "c43bd1fd-9b19-4f5d-b652-5aadd223d59f": {"doc_hash": "2801853c10a516866a92bf0fea5b33f13c8f8835bb198de3f19ed000d589a04c"}, "fda9e915-ef8b-40e6-bd59-c2873b369545": {"doc_hash": "2eb960d08f1e8bec2a9025d1e10ef50f0f104b9e9f68044fca30e069d580d370"}, "0c09c82c-3870-4881-a970-62550b020895": {"doc_hash": "f85838d63c62472b6aaad79d4d3d7ca1b3d3624a2d610233e2e9847c4d6eaf56"}, "db0fdb60-c128-4c26-ad59-632d2f5c0bfb": {"doc_hash": "4d18a95ccc323b91f9e59a56192e657fbbedca5fc4b08d4af5e6ba6c2eb20b72"}, "3a7b4754-e785-419c-b701-5ac6bb7eba09": {"doc_hash": "93bcc736934bd3048ef522f4b5f63392af1b942d5ef3bbe820a479b6d585b01c"}, "37721021-280e-434f-b167-3d7d12f73c7e": {"doc_hash": "de16d9a30fb1729c96f0d9ae7c29552c4097b5d2b3d0b846a19c81f3a82abddc"}, "2bab7572-b189-450e-8c30-045a78763a52": {"doc_hash": "e9b29bb693bd3457725d17930daef29d5aaec606d9ca176d04bc96000dccfd3f"}, "d2c4ead3-34bd-4333-b2c4-461303d6fb05": {"doc_hash": "2309f88e37698671bb7b6e4347e01d0523075efd3cf01bec81df95163a445ba3"}}, "docstore/data": {"af034d0a-df35-4ca7-ab54-cc1d6b0c96b0": {"__data__": {"text": "\ufeffIntroduction\nPyth Network is an oracle that publishes financial market data to multiple blockchains. Our market data is contributed by over 80 first-party publishers, including some of the biggest exchanges and market making firms in the world. We offer price feeds for a number of different asset classes, including US equities, commodities, and cryptocurrencies. Each price feed publishes a robust aggregate of publisher prices that updates multiple times per second.\nPrice feeds are available on multiple blockchains and can also be used in off-chain applications. Pyth offers two sets of price feeds for different applications:\n* \u200bSolana Price Feeds are available in mainnet for Solana\n* \u200bPythnet Price Feeds are available in mainnet for most EVM chains, including Ethereum, BNB, Avalanche, and more. These feeds are also available in Aptos mainnet and will be coming soon to Cosmos chains and other ecosystems.\nApplication developers can follow the links above to learn more about how to consume Pyth Network data for the relevant ecosystem.\n\n\nSolana Price Feeds\nSolana Price Feeds continuously stream price updates to the Solana blockchain. Each price feed is stored in a separate Solana account. Application developers can simply pass the relevant account to their solana program, then deserialize the data in the accounts to read the current value of the feed. Pyth provides a Solana SDK to assist with this process.\nBefore getting started with the SDK, please read Using Price Feeds to understand how Pyth price feeds are represented, and to learn best practices to use Pyth prices safely and correctly.\n\n\nUsing Price Feeds\nBest Practices for using Pyth Price Feeds\nThis page provides some technical details about Pyth price feeds that are necessary to use them safely and correctly. Please read this page before using Pyth price feeds in your application.\nPrice Feed Account IDs\nEach Pyth Network price feed is stored in a Solana account and is uniquely identified by its corresponding Solana account key. Price feeds have different ids in mainnet than in testnet or devnet. The full list of price feeds available on Solana is listed on the pyth.network website under the \"mainnet-beta\" tag. The price feed ids page lists the id of each available price feed. To use a price feed on-chain, look up its id using this page, then store the feed id in your program. You should then pass in the corresponding Solana account to any instruction that requires the current price and validate in your program that the account key matches the stored price feed id.\nFixed-Point Numeric Representation\nPrice feeds represent numbers in a fixed-point format. The same exponent is used for both the price and confidence interval. The integer representation of these values can be computed by multiplying by 10^exponent\n\n\nPrice Availability\nSometimes, Pyth will not be able to provide a current price for a product. This situation can happen for various reasons. For example, US equity markets only trade during certain hours, and outside those hours, it's not clear what an equity's price is. Alternatively, a network outage (at the internet level, blockchain level, or at multiple data providers) may prevent the protocol from producing new price updates. (Such outages are unlikely, but integrators should still be prepared for the possibility.) In such cases, Pyth may return a stale price for the product.\nIntegrators should be careful to avoid accidentally using a stale price. The SDKs guard against this failure mode by incorporating a staleness check by default. Querying the current price will fail if too much time has elapsed since the last update. The SDKs expose this failure condition in an idiomatic way: for example, the Rust SDK may return None, and our Solidity SDK may revert the transaction. The SDK provides a sane default for the staleness threshold, but users may configure it to suit their use case.\nMarket Hours\nPyth price feeds follow the traditional market hours of each asset classes\n\n\nLatency\nDevelopers integrating Pyth Network price feeds should account for the difference in latency between on-chain oracles and off-chain sources (e.g. centralized exchanges). Although Pyth Network is designed with low latency in mind, no on-chain oracle can match the latency of an", "doc_id": "af034d0a-df35-4ca7-ab54-cc1d6b0c96b0", "embedding": null, "doc_hash": "6e8bee0157c75a6c5a240ecd628e5dee1ece056caed1142e19bf167ad7dde817", "extra_info": null, "node_info": {"start": 0, "end": 4292}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "3": "36cbf504-e155-454a-84db-f6aa672a4d97"}}, "__type__": "1"}, "36cbf504-e155-454a-84db-f6aa672a4d97": {"__data__": {"text": "The SDKs guard against this failure mode by incorporating a staleness check by default. Querying the current price will fail if too much time has elapsed since the last update. The SDKs expose this failure condition in an idiomatic way: for example, the Rust SDK may return None, and our Solidity SDK may revert the transaction. The SDK provides a sane default for the staleness threshold, but users may configure it to suit their use case.\nMarket Hours\nPyth price feeds follow the traditional market hours of each asset classes\n\n\nLatency\nDevelopers integrating Pyth Network price feeds should account for the difference in latency between on-chain oracles and off-chain sources (e.g. centralized exchanges). Although Pyth Network is designed with low latency in mind, no on-chain oracle can match the latency of an off-chain source due to the added overhead for consensus and security. The threat model for integrating protocols should assume that adversaries see price changes a short time before the protocol does. In this threat model, protocol designers should avoid situations where a Pyth price update must race against an adversary's transaction. Adversaries are highly likely to win these races, as they have a head start, and sophisticated adversaries can additionally optimize their network latencies or pay miners for priority blockspace.\nThis situation is analogous to market making in traditional finance. Market makers place resting orders on exchanges with the hope of earning the bid/ask spread. When the \u201ctrue price\u201d moves, these market makers get picked off by adverse \u201csmart flow\u201d that is faster than they are. The smart flow is balanced by two-way flow, that is, people wanting to trade for other reasons besides a price change.\nThis analogy suggests two simple solutions to races:\n1. 1.\nConfigure protocol parameters to balance the losses from smart flow against the gains from two-way flow. Market makers in traditional finance implement this approach by offering a bid/ask spread and limited liquidity. The limited liquidity caps the losses to smart flow, while still earning profits from the two-way flow. A successful market maker tunes the spread and offered liquidity to limit adverse selection from smart traders while still interacting with two-way flow.\n2. 2.\nGive the protocol a \"last look\" to decide which transactions to accept. In traditional finance, some exchanges give market makers a chance to walk back a trade offer after someone else has requested it. Protocols can implement this technique by splitting transactions into two parts: a request and a fulfillment. In the first transaction, the user requests to perform an action. In the second transaction, the protocol chooses whether or not to fulfill the user's request; this step can be implemented as a permissionless operation. The protocol can require a short delay between the two transactions, and the user's request gets fulfilled at the Pyth price as of the second transaction. This technique gives the protocol extra time to observe price changes, giving it a head start in the latency race.\nConfidence Intervals\nAt every point in time, Pyth publishes both a price and a confidence interval for each product. For example, Pyth may publish the current price of bitcoin as $50000 \u00b1 $10. Pyth publishes a confidence interval because, in real markets, there is no one single price for a product. For example, at any given time, bitcoin trades at different prices at different venues around the world. While these prices are typically similar, they can diverge for a number of reasons, such as when a cryptocurrency exchange blocks withdrawals on an asset. If this happens, prices diverge because arbitrageurs can no longer bring prices across exchanges into line. Alternatively, prices on different venues can differ simply because an asset is highly volatile at a particular point in time. At such times, bid/ask spreads tend to be wider, and trades on different markets at around the same time tend to occur at a wider range of prices.\nPyth represents these possibly-different prices by giving its users a probability distribution over price instead of just a single price. Pyth models the price according to a Laplace distribution centered on the Pyth aggregate price with a standard deviation", "doc_id": "36cbf504-e155-454a-84db-f6aa672a4d97", "embedding": null, "doc_hash": "629e4bcffab80bf3bc2a2d80c1c5f85e99b2b6cf7ab9395fa584fdbc12b9413d", "extra_info": null, "node_info": {"start": 3605, "end": 7899}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "af034d0a-df35-4ca7-ab54-cc1d6b0c96b0", "3": "d9221246-58c7-4715-8469-6fd0943fd3a7"}}, "__type__": "1"}, "d9221246-58c7-4715-8469-6fd0943fd3a7": {"__data__": {"text": "different venues around the world. While these prices are typically similar, they can diverge for a number of reasons, such as when a cryptocurrency exchange blocks withdrawals on an asset. If this happens, prices diverge because arbitrageurs can no longer bring prices across exchanges into line. Alternatively, prices on different venues can differ simply because an asset is highly volatile at a particular point in time. At such times, bid/ask spreads tend to be wider, and trades on different markets at around the same time tend to occur at a wider range of prices.\nPyth represents these possibly-different prices by giving its users a probability distribution over price instead of just a single price. Pyth models the price according to a Laplace distribution centered on the Pyth aggregate price with a standard deviation equal to the confidence interval (the scale parameter b of the Laplace distribution is equal to the standard deviation divided by the square root of 2). The Laplace distribution contains ~95% of the probability mass within ~2.12 standard deviations (~3 times the scale parameter). If markets are behaving normally, then the confidence interval will be tight -- typically much less than 1% of the price -- and the Laplace distribution will be highly peaked. However, at unusual times, the confidence interval can widen out dramatically.\nWhen consuming Pyth prices, we recommend using the confidence interval to protect your users from these unusual market conditions. The simplest way to do so is to use Pyth's confidence interval to compute a range in which the true price (probably) lies. You obtain this range by adding and subtracting a multiple of the confidence interval to the Pyth price; the bigger the multiple, the more likely the price lies within that range. We recommend considering a multiple of 2.12, which as mentioned above gives you a 95% probability that the true price is within the range (assuming Laplace distribution estimates are correct). Then, select the most conservative price within that range for every action. In other words, your protocol should minimize state changes during times of large price uncertainty.\nThis principle is common sense. Imagine that you are lending money to a friend, and your friend pledges a bitcoin as collateral. Also imagine that Pyth says the bitcoin price is $50000 +- $1000. (Note that $1000 is an unusually large confidence interval for bitcoin; the confidence interval is typically ~$50 dollars). You therefore calculate that the true price is between $47880 and $52120 using the multiply by 3 rule from above. When originating the loan, you would value the bitcoin at $47880. The lower price is conservative in this instance because it limits the amount of borrowing that is possible while the price is uncertain. On the other hand, once the loan has been issued, you would value the bitcoin at $52120. The higher price is conservative, as it prevents you from liquidating your friend purely due to increased price uncertainty.\nThe same principle would apply if you wrote a derivative contract. If someone wants to open a derivative contract with you, you would value their collateral at the lower price. However, if you were deciding whether someone's margin limits were violated, you would value their collateral at the higher price. If a contract needs to be settled at a price, you could take approaches such as the following:\n   1. 1.\nUsing Pyth's exponential moving average price, which represents estimates of the average price of the asset over a specified time period (e.g., over the past 1 hour). The exponential moving average price is computed such that it lessens the influence of prices with wide confidence intervals. You may find more details in EMA Price Aggregation.\n   2. 2.\nUsing the aggregate price, which is Pyth's best estimate of the price at a single point in time. The quality of this estimate depends on the width of the confidence interval at settlement time and on occasion, it may be imprecise. However, it is the best you can do with Pyth data if you need a single price at that exact point in time.\n   3. 3.\nDefining the contract to depend on confidence. For example, you could create an option that refunds the option premium to the buyer (so both sides of the transaction are", "doc_id": "d9221246-58c7-4715-8469-6fd0943fd3a7", "embedding": null, "doc_hash": "42e2f3a90e1b5aac283423b6fe6062735eb51cc92b7fec599f4e90aef56f77cb", "extra_info": null, "node_info": {"start": 7889, "end": 12193}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "36cbf504-e155-454a-84db-f6aa672a4d97", "3": "0064fcec-49eb-41c7-a186-d51a25bf0c27"}}, "__type__": "1"}, "0064fcec-49eb-41c7-a186-d51a25bf0c27": {"__data__": {"text": "of the average price of the asset over a specified time period (e.g., over the past 1 hour). The exponential moving average price is computed such that it lessens the influence of prices with wide confidence intervals. You may find more details in EMA Price Aggregation.\n   2. 2.\nUsing the aggregate price, which is Pyth's best estimate of the price at a single point in time. The quality of this estimate depends on the width of the confidence interval at settlement time and on occasion, it may be imprecise. However, it is the best you can do with Pyth data if you need a single price at that exact point in time.\n   3. 3.\nDefining the contract to depend on confidence. For example, you could create an option that refunds the option premium to the buyer (so both sides of the transaction are even) if the strike price is within the confidence interval at settlement time. You could also create a contract that delayed settlement until the confidence interval was sufficiently small. If you choose this second option, you should ensure that your contract is guaranteed to eventually settle even if the confidence interval never narrows.\nSolana SDKs\nConsume Pyth prices in Solana programs.\nWe provide one SDK for Solana on-chain programs to use Pyth prices:\nThe pyth-sdk-solana crate can be used to consume Pyth prices inside Solana programs written in Rust.\nPrice Feed IDs\nThe price feeds available on each Solana network are listed on the following pages:\n      * Devnet\n      * Testnet\n      * Mainnet-Beta\nPythnet Price Feeds\nPythnet price feeds use an on-demand price update model, where users are responsible for posting price updates on-chain when needed. Please see On-Demand Updates to learn more about this model and what this means for integrators.\nIn the on-demand model, developers should integrate Pyth into both their on-chain and off-chain code:\n      1. 1.\n      2. On-chain programs should read prices from the Pyth program deployed on the same chain\n      3. 2.\n      4. Off-chain frontends and jobs should include Pyth price updates alongside (or within) their application-specific transactions.\nPyth provides ecosystem-specific SDKs to assist with both the on- and off-chain pieces of the integration. The easiest way to use Pyth price feeds is to integrate the appropriate SDKs into your application. Before getting started with an SDK, please read Using Price Feeds to understand how Pyth price feeds are represented, and to learn best practices to use Pyth prices safely and correctly.\nOn-Demand Updates\nPyth Network uses an on-demand price update model that is slightly different from other oracles you may be more familiar with. Most oracles today use a push model, where the oracle runs an off-chain process that continuously sends transactions to update an on-chain price. In contrast, Pyth Network does not operate an off-chain process that pushes prices on-chain. Instead, it delegates this work to Pyth Network users. Pyth price updates are created on Pythnet and streamed off-chain via the Wormhole Network, a cross-chain messaging protocol. These updates are signed such that the Pyth on-chain program can verify their authenticity. Updating the on-chain price is a permissionless operation: anyone can submit a valid Wormhole message to the Pyth contract to update the price. Typically, users of Pyth Network prices will submit a single transaction that simultaneously updates the price and uses it in a downstream application.\nOn-chain prices can only move forward in time. If a user submits a Wormhole message with a less recent price the Pyth program will not fail but will also not update the price. This in particular means that there's no guarantee that when a user atomically updates the price and then interacts with an application powered by Pyth, the price that the application will read will be equal to the price the user submitted.\nYou can find an in-depth explanation from one of our contributors, Jayant: Explaining the Pyth Network On-Demand Oracle Model:", "doc_id": "0064fcec-49eb-41c7-a186-d51a25bf0c27", "embedding": null, "doc_hash": "052e6a8eea7dbf6b937ca956c19b83d962ec8ed3b58c44b49f27ce194099dafb", "extra_info": null, "node_info": {"start": 12242, "end": 16249}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "d9221246-58c7-4715-8469-6fd0943fd3a7", "3": "aff9ae8a-438d-4250-9f8e-e909ac29e855"}}, "__type__": "1"}, "aff9ae8a-438d-4250-9f8e-e909ac29e855": {"__data__": {"text": "their authenticity. Updating the on-chain price is a permissionless operation: anyone can submit a valid Wormhole message to the Pyth contract to update the price. Typically, users of Pyth Network prices will submit a single transaction that simultaneously updates the price and uses it in a downstream application.\nOn-chain prices can only move forward in time. If a user submits a Wormhole message with a less recent price the Pyth program will not fail but will also not update the price. This in particular means that there's no guarantee that when a user atomically updates the price and then interacts with an application powered by Pyth, the price that the application will read will be equal to the price the user submitted.\nYou can find an in-depth explanation from one of our contributors, Jayant: Explaining the Pyth Network On-Demand Oracle Model: Pyth Tutorials\u200b\nAdvantages\nThe on-demand model has several benefits over the push model:\n      * Gas efficiency -- On-chain prices are only updated when they are needed. In the push model, the oracle can waste gas by submitting price updates that no one will use. Furthermore, the cost of updating the oracle is distributed amongst its users instead of borne entirely by Pyth Network. The cost of maintaining the on-chain prices can be substantial for a single entity, but is minimal when spread across all users. Many of the subsequent advantages follow from the fact that Pyth Network does not have to pay gas fees for every single update.\n      * High update frequency -- Pyth Network price feeds update once per second, which is faster than the blocktime of most blockchains. Such frequent updates would not be possible if every price had to be pushed on-chain. However, push oracles typically update even less frequently than the blocktime, because it is simply too expensive to update feeds more frequently.\n      * Low latency -- Every transaction can use a recent off-chain price, instead of relying on the last on-chain update pushed by the oracle itself.\n      * More price feeds -- Pyth Network can scale to thousands of price feeds due to its gas efficiency. The oracle incurs no added costs for each additional feed, and users pay gas costs for new feeds only when those feeds are used on-chain.\n      * Reliable in volatile conditions -- Push oracles can fail to land price updates in volatile market conditions. In these conditions, the oracle competes with other more valuable transactions (such as DEX trades or liquidations) for bandwidth, and often cannot pay enough to land price updates. This problem does not occur in the on-demand model, as Pyth price updates are incorporated into the valuable transactions themselves.\n      * Common infrastructure -- Every component of Pyth Network is shared across blockchains except for the contract deployed on the destination chain. These shared components can therefore be built with high reliability and accuracy targets, benefitting every chain the oracle is deployed on. This approach also allows Pyth Network to rapidly launch on new blockchains and ecosystems with all of the existing price feeds.\n      * Sustainable -- The Pyth Network protocol has been designed to allow for the optional enablement of data fees to update the state of an on-chain price feed. These fees will compensate data providers for their effort and motivates them to contribute additional data. Oracles without such a mechanism are inherently unsustainable and likely to fail if the operating organization runs out of money.\nIntegration\nDevelopers integrating with Pyth Network should build their application to submit the necessary price updates on their users' behalf. For example, if you need the BTC/USD price on-chain, then your frontend should submit the BTC/USD Pyth price update in every transaction that needs it. The Pyth Network SDKs cover both parts of this integration -- frontend and contract -- and are designed to simplify this process. These SDKs are blockchain-specific and are described in more detail in the subsequent sections of this documentation. Developers should also host an instance of the price service, which is a convenient wrapper around the Wormhole Network that the frontend SDKs use to fetch on-demand", "doc_id": "aff9ae8a-438d-4250-9f8e-e909ac29e855", "embedding": null, "doc_hash": "8da20c4c46ad83afe34e185fcfd98ee7b4480ce9f53728834f5045f5465bf300", "extra_info": null, "node_info": {"start": 16180, "end": 20421}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "0064fcec-49eb-41c7-a186-d51a25bf0c27", "3": "28058ec8-d0f4-4543-981f-af8ff857355f"}}, "__type__": "1"}, "28058ec8-d0f4-4543-981f-af8ff857355f": {"__data__": {"text": "motivates them to contribute additional data. Oracles without such a mechanism are inherently unsustainable and likely to fail if the operating organization runs out of money.\nIntegration\nDevelopers integrating with Pyth Network should build their application to submit the necessary price updates on their users' behalf. For example, if you need the BTC/USD price on-chain, then your frontend should submit the BTC/USD Pyth price update in every transaction that needs it. The Pyth Network SDKs cover both parts of this integration -- frontend and contract -- and are designed to simplify this process. These SDKs are blockchain-specific and are described in more detail in the subsequent sections of this documentation. Developers should also host an instance of the price service, which is a convenient wrapper around the Wormhole Network that the frontend SDKs use to fetch on-demand updates.\nFees\nThe Pyth Network protocol has been designed to allow for the optional enablement of data fees in order to update the state of an on-chain price feeds. The ongoing existence of and size of the fee will be determined by governance on a per-blockchain basis; until governance is live, the fee will be 1 of the smallest denomination of the blockchain's native token (e.g., 1 wei on Ethereum). The fees collected by the protocol will go toward compensating data providers and possibly other uses as determined by governance.\nNote that protocols integrating with Pyth Network can pass these fees along to their users. Whenever a user submits a transaction that requires a price update, that transaction can also include payment of the necessary fee. This approach charges end users in proportion to their usage of Pyth Network data. The Pyth Network SDKs use this approach by default and include all of the necessary logic for computing and sending the fee along with every transaction.\nIn addition to update fees, end users ultimately bear the gas cost of updating the Pyth Network price feeds, which means that their transactions cost a little more than they would in the push model. However, the cost of a single price update is minimal, so the combined gas and update fee should only be a small portion of the overall transaction cost for the end user.\nAdversarial selection\nOn-demand price updates gives users of Pyth Network some ability to select which price to use in a transaction. This ability is highly circumscribed by various constraints: on-chain prices must move forward in time and cannot be from too far in the past. However, users can still chose any price update that satisfies these constraints. This ability is functionally equivalent to latency: it allows users to see the price in the future before using a price from the past.\nThe simplest way to guard against this attack vector is to incorporate a staleness check to ensure that the price used in a transaction is sufficiently recent. The Pyth Network SDKs include this check by default, where queries for the price will fail if the on-chain time differs from the price's timestamp by more than a threshold amount. The default threshold is set per-chain, but is typically around 1 minute. Highly latency-sensitive protocols may wish to reduce this threshold to a few seconds to better suit their needs. Please also see the section on latency mitigations for additional ideas on how latency-sensitive protocols can minimize the impact of oracle latency.\n\n\nPyth on EVM\nConsume Pyth Network prices in EVM applications\nOn-chain EVM programs can use the Solidity SDK to read Pyth prices. The off-chain portion of the application can use pyth-evm-js to generate price update transactions. This repository's Quickstart includes an example of both the on- and off-chain code necessary to integrate with Pyth.\nExample - Oracle Swap\n\u200bOracle Swap is an end-to-end example application that uses Pyth Network. This application is an AMM that allows users to swap two assets at the Pyth-provided exchange rate. This application contains both the contract, and the frontend to interact with the contract.\nEVM price pusher\n\u200bPyth EVM price pusher is a service that regularly pushes price updates to the on-chain Pyth contract. Protocols can run this service to push regular updates to the on-chain Pyth price based on various conditions, such", "doc_id": "28058ec8-d0f4-4543-981f-af8ff857355f", "embedding": null, "doc_hash": "9b4d86921334b65c34c81e088006de8bbd7c6e56b09e5da690404fef9afb48ff", "extra_info": null, "node_info": {"start": 20390, "end": 24687}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "aff9ae8a-438d-4250-9f8e-e909ac29e855", "3": "92578429-7931-4b0b-be3f-bddbb73b492e"}}, "__type__": "1"}, "92578429-7931-4b0b-be3f-bddbb73b492e": {"__data__": {"text": "can use the Solidity SDK to read Pyth prices. The off-chain portion of the application can use pyth-evm-js to generate price update transactions. This repository's Quickstart includes an example of both the on- and off-chain code necessary to integrate with Pyth.\nExample - Oracle Swap\n\u200bOracle Swap is an end-to-end example application that uses Pyth Network. This application is an AMM that allows users to swap two assets at the Pyth-provided exchange rate. This application contains both the contract, and the frontend to interact with the contract.\nEVM price pusher\n\u200bPyth EVM price pusher is a service that regularly pushes price updates to the on-chain Pyth contract. Protocols can run this service to push regular updates to the on-chain Pyth price based on various conditions, such as a minimum update frequency, or a price change threshold. This service is useful for protocols that already depend on regular push updates and want to simplify migrating to Pyth. Please see the github readme for additional information on this service.\nIn addition, you can find an in-depth explanation from one of our contributors, Ali: How to Build with Pyth Data on EVM Chains (with Pusher): Pyth Tutorials\u200b\nNetworks\nPyth is currently available on the following EVM-based chains:\nMainnet\nNetwork\n\tContract address\n\tAvalanche\n\t0x4305FB66699C3B2702D4d05CF36551390A4c69C6\n\tFantom\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tPolygon\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tBNB\n\t0x4D7E825f80bDf85e913E0DD2A2D54927e9dE1594\n\tEthereum\n\t0x4305FB66699C3B2702D4d05CF36551390A4c69C6\n\tOptimism\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tAurora\n\t0xF89C7b475821EC3fDC2dC8099032c05c6c0c9AB9\n\tArbitrum\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tCelo\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tKCC\n\t0xE0d0e68297772Dd5a1f1D99897c581E2082dbA5B\n\tCronos\n\t0xE0d0e68297772Dd5a1f1D99897c581E2082dbA5B\n\tzkSync Era\n\t0xf087c864AEccFb6A2Bf1Af6A0382B0d0f6c5D834\n\tEVMOS\n\t0x354bF866A4B006C9AF9d9e06d9364217A8616E12\n\tPolygon zkEVM\n\t0xC5E56d6b40F3e3B5fbfa266bCd35C37426537c65\n\tMeter\n\t0xbFe3f445653f2136b2FD1e6DdDb5676392E3AF16\n\tConflux eSpace\n\t0xe9d69CdD6Fe41e7B621B4A688C5D1a68cB5c8ADc\n\tCanto\n\t0x98046Bd286715D3B0BC227Dd7a956b83D8978603\n\tTestnet\nNetwork\n\tContract address\n\tGoerli (Ethereum testnet)\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tFuji (Avalanche", "doc_id": "92578429-7931-4b0b-be3f-bddbb73b492e", "embedding": null, "doc_hash": "3afbb249d608b390d9190872b8f27f97e78092708488aa8f8c58a3df17ed6a46", "extra_info": null, "node_info": {"start": 24774, "end": 27105}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "28058ec8-d0f4-4543-981f-af8ff857355f", "3": "ee37f4fc-62f2-4bcc-9b18-0ec6f0416c5b"}}, "__type__": "1"}, "ee37f4fc-62f2-4bcc-9b18-0ec6f0416c5b": {"__data__": {"text": "zkEVM\n\t0xC5E56d6b40F3e3B5fbfa266bCd35C37426537c65\n\tMeter\n\t0xbFe3f445653f2136b2FD1e6DdDb5676392E3AF16\n\tConflux eSpace\n\t0xe9d69CdD6Fe41e7B621B4A688C5D1a68cB5c8ADc\n\tCanto\n\t0x98046Bd286715D3B0BC227Dd7a956b83D8978603\n\tTestnet\nNetwork\n\tContract address\n\tGoerli (Ethereum testnet)\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tFuji (Avalanche testnet)\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tFantom testnet\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tMumbai (Polygon testnet)\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tBNB testnet\n\t0xd7308b14BF4008e7C7196eC35610B1427C5702EA\n\tAurora testnet\n\t0x4305FB66699C3B2702D4d05CF36551390A4c69C6\n\tOptimism Goerli (testnet)\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tCelo Alfajores (testnet)\n\t0xff1a0f4744e8582DF1aE09D5611b887B6a12925C\n\tKCC testnet\n\t0x15D35b8985e350f783fe3d95401401E194ff1E6f\n\tCronos testnet\n\t0xBAEA4A1A2Eaa4E9bb78f2303C213Da152933170E\n\tArbitrum Goerli (testnet)\n\t0x939C0e902FF5B3F7BA666Cc8F6aC75EE76d3f900\n\tzkSync Era Goerli (testnet)\n\t0xC38B1dd611889Abc95d4E0a472A667c3671c08DE\n\tBase Goerli (testnet)\n\t0x5955C1478F0dAD753C7E2B4dD1b4bC530C64749f\n\tShimmer testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tChiado (Gnosis testnet)\n\t0xdDAf6D29b8bc81c1F0798a5e4c264ae89c16a72B\n\tEVMOS testnet\n\t0x354bF866A4B006C9AF9d9e06d9364217A8616E12\n\tNeon devnet\n\t0x2FF312f50689ad279ABb164dB255Eb568733BD6c\n\tPolygon zkEVM testnet\n\t0xd54bf1758b1C932F86B178F8b1D5d1A7e2F62C2E\n\tCanto testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tMeter testnet\n\t0x5fF5B9039FbD8256864A4460B7EA77093A65B1b5\n\tMantle testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tConflux eSpace testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tPyth on Aptos\nConsume Pyth Network prices in applications on Aptos\nAptos contracts can update and fetch the Pyth prices using the", "doc_id": "ee37f4fc-62f2-4bcc-9b18-0ec6f0416c5b", "embedding": null, "doc_hash": "35fffb1cc4c5e66724ab23041cafe210ae77c22364a3c07478b0b5faa477bc1c", "extra_info": null, "node_info": {"start": 27444, "end": 29237}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "92578429-7931-4b0b-be3f-bddbb73b492e", "3": "1a642690-1439-47fe-a96f-08f0fd23f841"}}, "__type__": "1"}, "1a642690-1439-47fe-a96f-08f0fd23f841": {"__data__": {"text": "testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tMeter testnet\n\t0x5fF5B9039FbD8256864A4460B7EA77093A65B1b5\n\tMantle testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tConflux eSpace testnet\n\t0xA2aa501b19aff244D90cc15a4Cf739D2725B5729\n\tPyth on Aptos\nConsume Pyth Network prices in applications on Aptos\nAptos contracts can update and fetch the Pyth prices using the Pyth Aptos Contract, which has been deployed on Mainnet. The documented source code can be found here.\nUpdating Price Feeds\nThe mechanism by which price feeds are updated on Aptos is explained here. The pyth-aptos-js package can be used to fetch price feed update data which can be passed to the pyth::update_price on-chain function.\nNetworks\nPyth is currently deployed on Aptos Mainnet and Testnet.\nAddresses\nWhen deploying contracts using Pyth, the named addresses pyth, wormhole and deployer need to be defined at compile time. These addresses are the same across both Testnet and Mainnet.\nNamed Address\n\tValue\n\tpyth\n\t0x7e783b349d3e89cf5931af376ebeadbfab855b3fa239b7ada8f5a92fbea6b387\n\twormhole\n\t0x5bc11445584a763c1fa7ed39081f1b920954da14e04b32440cba863d03e19625\n\tdeployer\n\t0xb31e712b26fd295357355f6845e77c888298636609e93bc9b05f0f604049f434\n\tdeployer and wormhole are implementation details of the Pyth contract: you will not need to interact with these.\nPrice Feeds\nNetwork\n\tAvailable Price Feeds\n\tAptos Testnet\n\thttps://pyth.network/developers/price-feed-ids#aptos-testnet\n\tAptos Mainnet\n\thttps://pyth.network/developers/price-feed-ids#aptos-mainnet\n\tPyth on Sui\nPyth on Sui\nContents\n      1. 1.\n      2. Background\n      3. 2.\n      4. How to Update and Consume Price Feeds\n      5. 3.\n      6. Examples\n      7. 4.\n      8. Contracts Registry (addresses)\n      9. 5.\n      10. Common Questions how How to Integrate with Pyth on Sui\n1. Background\nPyth price feeds on Sui are uniquely represented in the global store as PriceInfoObjects. These objects have the key ability and serve as wrappers around the PriceInfo object, which in turn contains the price info: namely the PriceFeed, the arrival time of the latest price update, and the attestation time of the latest update.\nPriceInfoObjects are central to Pyth on Sui, since they are in unique correspondence with each Pyth price feed and must be passed in to functions that update price feeds or which query info about price feeds, e.g.\n      * update_single_price_feed\n      * update_single_price_feeds_if_fresh\n      * get_price\n2. How to Update and Consume Price Feeds\nWe demo how to update and then consume a price feed by building a Sui programmable transaction off-chain, and then executing it to update a price feed and get an updated price.\nAs with other chains, one first obtains a batch price attestation VAA (of type vector<u8>) from a Pyth price service endpoint, which encodes update price information for a feed.\n1. wormhole::vaa::parse_and_verify\nCall parse_and_verify on the batch attestation VAA", "doc_id": "1a642690-1439-47fe-a96f-08f0fd23f841", "embedding": null, "doc_hash": "0da6c10a02e46af4ec52a368eae49c0c622762e83bf1021417837bb257fecf57", "extra_info": null, "node_info": {"start": 29221, "end": 32162}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "ee37f4fc-62f2-4bcc-9b18-0ec6f0416c5b", "3": "75a88da7-58fa-489e-aecc-a4dc0f73a898"}}, "__type__": "1"}, "75a88da7-58fa-489e-aecc-a4dc0f73a898": {"__data__": {"text": "feed and must be passed in to functions that update price feeds or which query info about price feeds, e.g.\n      * update_single_price_feed\n      * update_single_price_feeds_if_fresh\n      * get_price\n2. How to Update and Consume Price Feeds\nWe demo how to update and then consume a price feed by building a Sui programmable transaction off-chain, and then executing it to update a price feed and get an updated price.\nAs with other chains, one first obtains a batch price attestation VAA (of type vector<u8>) from a Pyth price service endpoint, which encodes update price information for a feed.\n1. wormhole::vaa::parse_and_verify\nCall parse_and_verify on the batch attestation VAA bytes to obtain a VAA hot potato object.\npublic fun parse_and_verify(\n     wormhole_state: &State,\n     buf: vector<u8>, // price update VAA bytes\n     the_clock: &Clock\n ): VAA\n2. pyth::pyth::update_single_price_feed\nUse the verified VAA and create a hot potato vector containing the latest price updates.\npublic fun create_price_infos_hot_potato(\n       pyth_state: &PythState,\n       verified_vaas: vector<VAA>,\n       clock: &Clock\n): HotPotatoVector<PriceInfo>\n3.pyth::pyth::update_single_price_feed\nUse the hot potato price updates vector to update a price feed.\nNote that conventional Pyth price IDs are found here. However, instead of passing in a Pyth price feed ID to update the price feed (which is what is done on other chains), one must pass in a PriceInfoObject ID instead.\nThe PriceInfoObject IDs are distinct from Pyth price feed IDs, and are stored in a map on-chain (Pyth price feed ID => PriceInfoObject ID). We pulled this map into a local json file here. The PriceInfoObject ID can also be queried on-chain by calling the pyth::state::get_price_info_object_id found in the Pyth package. See the common questions section below for more info.\npublic fun update_single_price_feed(\n   pyth_state: &PythState,\n   price_updates: HotPotatoVector<PriceInfo>,\n   price_info_object: &mut PriceInfoObject,\n   fee: Coin<SUI>,\n   clock: &Clock\n): HotPotatoVector<PriceInfo>\n4.pyth::hot_potato_vector::destroy\nDrop the hot potato. (You must call this function to drop the potato).\npublic fun destroy<T: copy + drop>(\n   hot_potato_vector: HotPotatoVector<T>\n)\n5. pyth::pyth::get_price\nFinally, get the price of the updated price feed in PriceInfoObject \ud83c\udf89\ud83c\udf89\ud83c\udf89.\npublic fun get_price(\n     state: &PythState,\n     price_info_object: &PriceInfoObject,\n     clock: &Clock\n): Price\n3. Examples\nSee the ./scripts folder for examples of programmable transactions for creating price feeds and updating price feeds.\n      * \u200bDemo for updating a price feed\u200b\nTo build and test the contracts, run the following\n$ make test\n$ make build\n4. Contracts Registry\nPyth on Testnet\n      * PYTH_PACKAGE_ID: 0x975e063f398f720af4f33ec06a927f14ea76ca24f7f8dd544aa62ab9d5d15f44\u200b\n      * PYTH_STATE_ID: 0xd8afde3a48b4ff7212bd6829a150f43f59043221200d63504d981f62bff2e27a\u200b\n      * PYTH_PRICE_FEED_ID_TO_PRICE_INFO_OBJECT_ID:", "doc_id": "75a88da7-58fa-489e-aecc-a4dc0f73a898", "embedding": null, "doc_hash": "43f7c544251a371a8bf5137305ae20398a8372bb97dc33ea18b2c9480b51cc21", "extra_info": null, "node_info": {"start": 31939, "end": 34924}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "1a642690-1439-47fe-a96f-08f0fd23f841", "3": "dcbd169d-4896-435e-a624-2e4e4495cdc0"}}, "__type__": "1"}, "dcbd169d-4896-435e-a624-2e4e4495cdc0": {"__data__": {"text": "price feeds.\n      * \u200bDemo for updating a price feed\u200b\nTo build and test the contracts, run the following\n$ make test\n$ make build\n4. Contracts Registry\nPyth on Testnet\n      * PYTH_PACKAGE_ID: 0x975e063f398f720af4f33ec06a927f14ea76ca24f7f8dd544aa62ab9d5d15f44\u200b\n      * PYTH_STATE_ID: 0xd8afde3a48b4ff7212bd6829a150f43f59043221200d63504d981f62bff2e27a\u200b\n      * PYTH_PRICE_FEED_ID_TO_PRICE_INFO_OBJECT_ID: 0xf8929174008c662266a1adde78e1e8e33016eb7ad37d379481e860b911e40ed5\u200b\nWormhole on Testnet\n      * WORMHOLE_PACKAGE_ID: 0xcc029e2810f17f9f43f52262f40026a71fbdca40ed3803ad2884994361910b7e\u200b\n      * WORMHOLE_STATE_ID: 0xebba4cc4d614f7a7cdbe883acc76d1cc767922bc96778e7b68be0d15fce27c02\u200b\nPyth on Mainnet\n      * PYTH_PACKAGE_ID: 0x00b53b0f4174108627fbee72e2498b58d6a2714cded53fac537034c220d26302\u200b\n      * PYTH_STATE_ID: 0xf9ff3ef935ef6cdfb659a203bf2754cebeb63346e29114a535ea6f41315e5a3f\u200b\n      * PYTH_PRICE_FEED_ID_TO_PRICE_INFO_OBJECT_ID: 0x14b4697477d24c30c8eecc31dd1bd49a3115a9fe0db6bd4fd570cf14640b79a0\u200b\nWormhole on Mainnet\n      * WORMHOLE_PACKAGE_ID: 0x5306f64e312b581766351c07af79c72fcb1cd25147157fdc2f8ad76de9a3fb6a\u200b\n      * WORMHOLE_STATE_ID: 0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c\u200b\n5. Common Questions on How to Integrate with Pyth on Sui\n1. What is up with the \"sui rev\"? (09b2081498366df936abae26eea4b2d5cafb2788). Why does it point to a specific commit hash instead of \"main\" or \"devnet\"?\nOur Pyth Move.toml file contains the following dependencies. It depends on specific versions of the Sui Framework as well as Wormhole. To make your Sui package compatible, you must also specify the following dependencies verbatim in your Move.toml file. We are locked in to this specific rev because our package depends on Wormhole, which uses the rev 09b2081498366df936abae26eea4b2d5cafb2788.\n[dependencies.Sui]\ngit = \"https://github.com/MystenLabs/sui.git\"\nsubdir = \"crates/sui-framework/packages/sui-framework\"\nrev = \"09b2081498366df936abae26eea4b2d5cafb2788\"\n\u200b\n[dependencies.Wormhole]\ngit = \"https://github.com/wormhole-foundation/wormhole.git\"\nsubdir = \"sui/wormhole\"\nrev = \"d050ad1d67a5b7da9fb65030aad12ef5d774ccad\"\n2. How do I find the Sui Object ID of a PriceInfoObject for", "doc_id": "dcbd169d-4896-435e-a624-2e4e4495cdc0", "embedding": null, "doc_hash": "f3fa3c15e6733ebb67b8ac93653a7e9fe57b7af21c8dbcaee2f1f3a7ad33f26d", "extra_info": null, "node_info": {"start": 35144, "end": 37351}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "75a88da7-58fa-489e-aecc-a4dc0f73a898", "3": "99f18e0f-d183-448f-bd78-2e6a1d9c7276"}}, "__type__": "1"}, "99f18e0f-d183-448f-bd78-2e6a1d9c7276": {"__data__": {"text": "on Wormhole, which uses the rev 09b2081498366df936abae26eea4b2d5cafb2788.\n[dependencies.Sui]\ngit = \"https://github.com/MystenLabs/sui.git\"\nsubdir = \"crates/sui-framework/packages/sui-framework\"\nrev = \"09b2081498366df936abae26eea4b2d5cafb2788\"\n\u200b\n[dependencies.Wormhole]\ngit = \"https://github.com/wormhole-foundation/wormhole.git\"\nsubdir = \"sui/wormhole\"\nrev = \"d050ad1d67a5b7da9fb65030aad12ef5d774ccad\"\n2. How do I find the Sui Object ID of a PriceInfoObject for a Pyth Price Feed?\nThe mapping of Pyth price feed IDs to PriceInfoObject object IDs can be found here. (Note: this may go out of date as more price feeds are introduced and created over time).\nThis mapping is also stored on-chain, and can be queried on-chain using the getter function pyth::state::get_price_info_object_id defined in the Pyth package.\nAlso recall that the list of Pyth price feed IDs can be found here.\n\n\nPyth on Cosmwasm\nConsume Pyth Network prices in applications on Cosmwasm\nCosmwasm contracts can update and fetch the Pyth prices using the Pyth Cosmwasm Contract, deployed on their network.\nUpdating Price Feeds\nThe mechanism by which price feeds are updated on Cosmwasm is explained here. The pyth-common-js can be used to fetch the latest price feed data which then can be passed to the ExecuteMsg on-chain function.\nExamples\n      * Minimal on-chain contract which queries the Pyth contract.\nNetworks\nPyth is currently available on the following cosmwasm chains:\nMainnet\nNetwork\n\tContract address\n\tInjective\n\tinj12j43nf2f0qumnt2zrrmpvnsqgzndxefujlvr08\n\tTestnet\nNetwork\n\tContract address\n\tInjective\n\tinj1yzx0wdn6t7xrjdpgztnrraq57nw2zxhstr97xw\n\tSei Atlantic 2\n\tsei1977nnu5jqatteqgve8tx7nzu9y7eh6cvq0e4g6xjx8tf5wm4nkmsfljunh\n\tOsmosis Test 4\n\tosmo1xws8v2yv50v0spn90yr9fe9zx8zxfppl3syn38zw59npvp8dd70sutnvsm\n\tOsmosis Test 5\n\tosmo12u2vqdecdte84kg6c3d40nwzjsya59hsj048n687m9q3t6wdmqgsq6zrlx\n\tNeutron Pion 1\n\tneutron1zpn7yhxqx2f0c6cpmp3fr42yafupz9elglvgdss2300c847ph0hsgurhlj\n\tJuno\n\tjuno1ygyhu0zn69zm0354nzpd7zrp5xs9vpkqcuk7kfneyghrpa87msmqeskxqa\n\t\n\nPyth on BAS Chains\nConsume Pyth Network prices in applications on BNB Application Sidechains\nDeployment\nIf, as is highly likely, your BAS chain doesn't already have a deployment of Pyth, you will need to deploy the pyth-crosschain receiver contracts yourself. This is easy to do and will enable contracts deployed on your BAS chain to consume Pyth price feeds from the PythUpgradable contract.\nTo deploy the pyth-crosschain receiver contracts to your BAS chain:\n      * Clone the pyth-crosschain repo.\n      * Add your BAS network details to the Truffle Networks configuration file. An example using BAS test net is configured as below:\n      * my_bas_testnet: {\n ", "doc_id": "99f18e0f-d183-448f-bd78-2e6a1d9c7276", "embedding": null, "doc_hash": "83b2e361dfb515b16ff53ab212aca9365c805db844c9a589899a0045a44c1bbd", "extra_info": null, "node_info": {"start": 37272, "end": 39964}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "dcbd169d-4896-435e-a624-2e4e4495cdc0", "3": "838dcec2-2964-4c54-81d4-81a4cd6aca9a"}}, "__type__": "1"}, "838dcec2-2964-4c54-81d4-81a4cd6aca9a": {"__data__": {"text": "on BAS Chains\nConsume Pyth Network prices in applications on BNB Application Sidechains\nDeployment\nIf, as is highly likely, your BAS chain doesn't already have a deployment of Pyth, you will need to deploy the pyth-crosschain receiver contracts yourself. This is easy to do and will enable contracts deployed on your BAS chain to consume Pyth price feeds from the PythUpgradable contract.\nTo deploy the pyth-crosschain receiver contracts to your BAS chain:\n      * Clone the pyth-crosschain repo.\n      * Add your BAS network details to the Truffle Networks configuration file. An example using BAS test net is configured as below:\n      * my_bas_testnet: {\n      *    provider: () => new HDWalletProvider(\n      *        process.env.MNEMONIC,\n      *        \"https://bas-aries-public.nodereal.io\"\n      *    ),\n      *    confirmations: 10,\n      *    networkCheckTimeout: 1000000,\n      *    timeoutBlocks: 1000,\n      *    skipDryRun: true,\n      *          network_id: 117,\n      * }\n      * Prepare a .env.prod.my_bas_testnet environment file in the pyth-crosschain/target_chains/ethereum directory. Please note if you test the deployment in the test net, you need use the Testnet pyth variable of PYTH_TO_WORMHOLE_EMITTER like below.\n      * # The truffle network name of your BAS chain, defined in the configuration earlier\n      * MIGRATIONS_NETWORK=my_bas_testnet\n      * \u200b\n      * # Keep these values the same\n      * MIGRATIONS_DIR=./migrations/prod-receiver   \n      * PYTH_TO_WORMHOLE_CHAIN_ID=0x1\n      * \u200b\n      * # Choose this value based on your network type (testnet, mainnet)\n      * # Testnet Pyth\n      * PYTH_TO_WORMHOLE_EMITTER=0xf346195ac02f37d60d4db8ffa6ef74cb1be3550047543a4a9ee9acf4d78697b0\n      * INIT_SIGNERS=[\"0x13947Bd48b18E53fdAeEe77F3473391aC727C638\"]\n      * INIT_GOV_CHAIN_ID=0x1\n      * INIT_GOV_CONTRACT=0x0000000000000000000000000000000000000000000000000000000000000004\n      * # Mainnet Pyth\n      * # PYTH_TO_WORMHOLE_EMITTER=0x6bb14509a612f01fbbc4cffeebd4bbfb492a86df717ebe92eb6df432a3f00a25\n      * # INIT_SIGNERS=[\"0x58CC3AE5C097b213cE3c81979e1B9f9570746AA5\"]\n      * # INIT_GOV_CHAIN_ID=0x1\n      * # INIT_GOV_CONTRACT=0x0000000000000000000000000000000000000000000000000000000000000004\n      * \u200b\n      * # Choose this value based on your network type (testnet, mainnet)\n      * # Testnet Pyth\n      *", "doc_id": "838dcec2-2964-4c54-81d4-81a4cd6aca9a", "embedding": null, "doc_hash": "0033494b871fd0c439363a946db286345fdca5bfc356af66f647cd20f80de746", "extra_info": null, "node_info": {"start": 39850, "end": 42195}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "99f18e0f-d183-448f-bd78-2e6a1d9c7276", "3": "cc79ba93-1ec7-4bc7-8e0c-8ac1ca28a73a"}}, "__type__": "1"}, "cc79ba93-1ec7-4bc7-8e0c-8ac1ca28a73a": {"__data__": {"text": "  * # PYTH_TO_WORMHOLE_EMITTER=0x6bb14509a612f01fbbc4cffeebd4bbfb492a86df717ebe92eb6df432a3f00a25\n      * # INIT_SIGNERS=[\"0x58CC3AE5C097b213cE3c81979e1B9f9570746AA5\"]\n      * # INIT_GOV_CHAIN_ID=0x1\n      * # INIT_GOV_CONTRACT=0x0000000000000000000000000000000000000000000000000000000000000004\n      * \u200b\n      * # Choose this value based on your network type (testnet, mainnet)\n      * # Testnet Pyth\n      * PYTH_TO_WORMHOLE_EMITTER=0xf346195ac02f37d60d4db8ffa6ef74cb1be3550047543a4a9ee9acf4d78697b0\n      * # Mainnet Pyth\n      * # PYTH_TO_WORMHOLE_EMITTER=0x6bb14509a612f01fbbc4cffeebd4bbfb492a86df717ebe92eb6df432a3f00a25\n      * Now, under the pyth2wormhole/ethereum directory, install dependencies.\n      * npm install\n      * Now run the Truffle migrations inside pyth-crosschain/target_chains/ethereum/migrations/prod-receiver/ using the instructions here. Make sure you are deploying using the right environment file and to the correct network.\n      * You can verify the contracts have been deployed successfully using the example here.\nUsage\nAfter the pyth2wormhole contracts have been deployed to your BAS chain, please refer to the Pyth on EVM-based chains documentation for how to consume price feeds.\n\n\nPyth for Off-chain Apps\nWe provide SDKs in various programming languages that allow you to read the values of Pyth price feeds in off-chain applications, such as web frontends:\nJavaScript\nRust\nPython\nGo\n\n\nPrice Service\nThe price service is a webservice that listens to the Wormhole Network for Pyth price updates and serves them via a convenient web API. The service allows users to easily query for recent price updates via a REST API, or subscribe to a websocket for streaming updates. The Pyth Network Javascript SDKs connect to an instance of the price service in order to fetch on-demand price updates.\nPublic Endpoints\nThe Pyth Data Association operates two public endpoints for the price service, for mainnet and testnet respectively. These endpoints can be used to test integrations with Pyth Network:\nnetwork\n\turl\n\tmainnet\n\thttps://xc-mainnet.pyth.network\n\ttestnet\n\thttps://xc-testnet.pyth.network\n\tFor production deployments, developers integrating with Pyth Network are strongly encouraged to host their own instance of the price service for maximum resilience and decentralization. By running an independent instance of this service, developers tap directly into Wormhole's peer-to-peer network to stream Pyth price updates. This peer-to-peer network has built-in redundancy and is therefore inherently more reliable than a centralized service operated by the PDA. Please find more information about building and running the price service from here.\n\n\nPrice Feed Batches\nPrice Feeds Batches\nThe Pythnet price feeds are batched together to optimize gas usage for applications using Pyth data on a blockchain. In other words, when your application retrieves one price feed and updates the price on-chain, it will automatically do it for four other assets\u2014those available in the same batch.\nBatches\nCurrently, the Pyth Data Association and contributors to the Pyth network are in charge of designing the rules around price feed batching\u2014which feeds are batched together\u2014and continuously maintaining those batches for an optimal user experience (more convenience, less cost)", "doc_id": "cc79ba93-1ec7-4bc7-8e0c-8ac1ca28a73a", "embedding": null, "doc_hash": "d87b7e4dd344f340b403d9d1340341698f1bf6ff0a9d758dda32464162c9f2e3", "extra_info": null, "node_info": {"start": 42400, "end": 45701}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "838dcec2-2964-4c54-81d4-81a4cd6aca9a", "3": "17e64f39-75b6-4ce5-8c48-02a7e74597c1"}}, "__type__": "1"}, "17e64f39-75b6-4ce5-8c48-02a7e74597c1": {"__data__": {"text": "This peer-to-peer network has built-in redundancy and is therefore inherently more reliable than a centralized service operated by the PDA. Please find more information about building and running the price service from here.\n\n\nPrice Feed Batches\nPrice Feeds Batches\nThe Pythnet price feeds are batched together to optimize gas usage for applications using Pyth data on a blockchain. In other words, when your application retrieves one price feed and updates the price on-chain, it will automatically do it for four other assets\u2014those available in the same batch.\nBatches\nCurrently, the Pyth Data Association and contributors to the Pyth network are in charge of designing the rules around price feed batching\u2014which feeds are batched together\u2014and continuously maintaining those batches for an optimal user experience (more convenience, less cost) when interacting with Pyth data on-chain.\nBatches are first segmented per asset type: Metal, FX, Equity, and Crypto. Crypto is the only asset class with sub-categories: stablecoins, fan tokens, or layer-1 types of tokens (ERC-20, SPL, TRC, BEP\u2026), etc. Then (and for all asset types), batches are filled with price feeds in descending alphabetical order.\nAll existing batches are listed below: group_name \tsymbols \tbatch_metal_1 \tMetal.XAG/USD \t\u200b \tMetal.XAU/USD \tbatch_fx_1 \tFX.AUD/USD \t\u200b \tFX.EUR/USD \t\u200b \tFX.NZD/USD \t\u200b \tFX.GBP/USD \t\u200b \tFX.USD/CAD \tbatch_fx_2 \tFX.USD/CHF \t\u200b \tFX.USD/CHN \t\u200b \tFX.USD/HKD \t\u200b \tFX.USD/JPY \t\u200b \tFX.USD/MXN \tbatch_fx_3 \tFX.USD/RUB \t\u200b \tFX.USD/SGD \t\u200b \tFX.USD/ZAR \tbatch_gb_equity_1 \tEquity.GB.IB01/USD \t\u200b \tEquity.GB.IBTA/USD \tbatch_us_equity_1 \tEquity.US.AAPL/USD \t\u200b \tEquity.US.AMC/USD \t\u200b \tEquity.US.AMGN/USD \t\u200b \tEquity.US.AMZN/USD \t\u200b \tEquity.US.AXP/USD \tbatch_us_equity_2 \tEquity.US.BA/USD \t\u200b \tEquity.US.CAT/USD \t\u200b \tEquity.US.CRM/USD \t\u200b \tEquity.US.CSCO/USD \t\u200b \tEquity.US.CVX/USD \tbatch_us_equity_3 \tEquity.US.DIS/USD \t\u200b \tEquity.US.DOW/USD \t\u200b \tEquity.US.EFA/USD \t\u200b \tEquity.US.GE/USD \t\u200b \tEquity.US.GME/USD \tbatch_us_equity_4 \tEquity.US.GOOG/USD \t\u200b \tEquity.US.GOVT/USD \t\u200b \tEquity.US.GS/USD \t\u200b \tEquity.US.HD/USD \t\u200b \tEquity.US.HON/USD \tbatch_us_equity_5 \tEquity.US.IBM/USD \t\u200b \tEquity.US.INTC/USD \t\u200b \tEquity.US.IVV/USD \t\u200b \tEquity.US.IWM/USD \t\u200b \tEquity.US.JNJ/USD \tbatch_us_equity_6 \tEquity.US.JPM/USD \t\u200b \tEquity.US.KO/USD \t\u200b \tEquity.US.MCD/USD \t\u200b \tEquity.US.MINT/USD \t\u200b \tEquity.US.MMM/USD \tbatch_us_equity_7 \tEquity.US.MRK/USD", "doc_id": "17e64f39-75b6-4ce5-8c48-02a7e74597c1", "embedding": null, "doc_hash": "6848c7f119ebaed4523216633deaad18b3f661b186ec61759204222ef2f4db80", "extra_info": null, "node_info": {"start": 45320, "end": 47707}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "cc79ba93-1ec7-4bc7-8e0c-8ac1ca28a73a", "3": "5fa0a9ae-5171-4a8b-a4b8-fe6018aab318"}}, "__type__": "1"}, "5fa0a9ae-5171-4a8b-a4b8-fe6018aab318": {"__data__": {"text": "\tEquity.US.IWM/USD \t\u200b \tEquity.US.JNJ/USD \tbatch_us_equity_6 \tEquity.US.JPM/USD \t\u200b \tEquity.US.KO/USD \t\u200b \tEquity.US.MCD/USD \t\u200b \tEquity.US.MINT/USD \t\u200b \tEquity.US.MMM/USD \tbatch_us_equity_7 \tEquity.US.MRK/USD \t\u200b \tEquity.US.MSFT/USD \t\u200b \tEquity.US.NFLX/USD \t\u200b \tEquity.US.NKE/USD \t\u200b \tEquity.US.PG/USD \tbatch_us_equity_8 \tEquity.US.QQQ/USD \t\u200b \tEquity.US.SHV/USD \t\u200b \tEquity.US.SPY/USD \t\u200b \tEquity.US.TLT/USD \t\u200b \tEquity.US.TRV/USD \tbatch_us_equity_9 \tEquity.US.TSLA/USD \t\u200b \tEquity.US.UNH/USD \t\u200b \tEquity.US.USO/USD \t\u200b \tEquity.US.V/USD \t\u200b \tEquity.US.VOO/USD \tbatch_us_equity_10 \tEquity.US.VZ/USD \t\u200b \tEquity.US.WBA/USD \t\u200b \tEquity.US.WMT/USD \t\u200b \tEquity.US.XLE/USD \tbatch_crypto_stablecoin_1 \tCrypto.BRZ/USD \t\u200b \tCrypto.BUSD/USD \t\u200b \tCrypto.CUSD/USD \t\u200b \tCrypto.DAI/USD \t\u200b \tCrypto.HAY/USD \tbatch_crypto_stablecoin_2 \tCrypto.TUSD/USD \t\u200b \tCrypto.USDC/USD \t\u200b \tCrypto.USDD/USD \t\u200b \tCrypto.USDT/USD \t\u200b \tCrypto.USTC/USD \tbatch_crypto_stablecoin_3 \tCrypto.VAI/USD \tbatch_crypto_fantoken_1 \tCrypto.ACM/USD \t\u200b \tCrypto.ALPINE/USD \t\u200b \tCrypto.ARG/USD \t\u200b \tCrypto.ASR/USD \t\u200b \tCrypto.ATM/USD \tbatch_crypto_fantoken_2 \tCrypto.BAR/USD \t\u200b \tCrypto.CHZ/USD \t\u200b \tCrypto.CITY/USD \t\u200b \tCrypto.GAL/USD \t\u200b \tCrypto.INTER/USD \tbatch_crypto_fantoken_3 \tCrypto.ITA/USD \t\u200b \tCrypto.JUV/USD \t\u200b \tCrypto.LAZIO/USD \t\u200b \tCrypto.OG/USD \t\u200b \tCrypto.POR/USD \tbatch_crypto_fantoken_4 \tCrypto.PORTO/USD \t\u200b \tCrypto.PSG/USD \t\u200b \tCrypto.SANTOS/USD \tbatch_crypto_eth_stakedeth \tCrypto.BETH/USD \t\u200b \tCrypto.CBETH/USD \t\u200b \tCrypto.ETH/USD \t\u200b \tCrypto.STETH/USD \t\u200b \tCrypto.RETH/USD \tbatch_crypto_sol_stakedsol \tCrypto.JITOSOL/USD \t\u200b \tCrypto.MSOL/USD \t\u200b \tCrypto.SCNSOL/USD \t\u200b \tCrypto.SOL/USD \t\u200b \tCrypto.STSOL/USD \tbatch_crypto_apt_stakedapt \tCrypto.APT/USD \t\u200b \tCrypto.TAPT/USD \tbatch_crypto_near_stakednear \tCrypto.NEAR/USD \t\u200b \tCrypto.STNEAR/USD \tbatch_crypto_blochchain_1", "doc_id": "5fa0a9ae-5171-4a8b-a4b8-fe6018aab318", "embedding": null, "doc_hash": "1fcf652bf2e7e4e1e9b62561294940e52c82a98a633e114cf2afef890c0d5b32", "extra_info": null, "node_info": {"start": 48242, "end": 50036}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "17e64f39-75b6-4ce5-8c48-02a7e74597c1", "3": "aa195a20-6c42-4962-8251-2e8e07339ddb"}}, "__type__": "1"}, "aa195a20-6c42-4962-8251-2e8e07339ddb": {"__data__": {"text": "\tCrypto.APT/USD \t\u200b \tCrypto.TAPT/USD \tbatch_crypto_near_stakednear \tCrypto.NEAR/USD \t\u200b \tCrypto.STNEAR/USD \tbatch_crypto_blochchain_1 \tCrypto.ADA/USD \t\u200b \tCrypto.ALGO/USD \t\u200b \tCrypto.AMB/USD \t\u200b \tCrypto.ATOM/USD \t\u200b \tCrypto.AVAX/USD \tbatch_crypto_blochchain_2 \tCrypto.BCH/USD \t\u200b \tCrypto.BNB/USD \t\u200b \tCrypto.BTC/USD \t\u200b \tCrypto.CELO/USD \t\u200b \tCrypto.CRO/USD \tbatch_crypto_blochchain_3 \tCrypto.DOGE/USD \t\u200b \tCrypto.DOT/USD \t\u200b \tCrypto.FLOW/USD \t\u200b \tCrypto.FTM/USD \t\u200b \tCrypto.HNT/USD \tbatch_crypto_blochchain_4 \tCrypto.INJ/USD \t\u200b \tCrypto.KCS/USD \t\u200b \tCrypto.LTC/USD \t\u200b \tCrypto.LUNA/USD \t\u200b \tCrypto.LUNC/USD \tbatch_crypto_blochchain_5 \tCrypto.MATIC/USD \t\u200b \tCrypto.ONE/USD \t\u200b \tCrypto.OP/USD \t\u200b \tCrypto.STRK/USD \t\u200b \tCrypto.XMR/USD \tbatch_crypto_spl_1 \tCrypto.ATLAS/USD \t\u200b \tCrypto.COPE/USD \t\u200b \tCrypto.FIDA/USD \t\u200b \tCrypto.GMT/USD \t\u200b \tCrypto.GOFX/USD \tbatch_crypto_spl_2 \tCrypto.HXRO/USD \t\u200b \tCrypto.JET/USD \t\u200b \tCrypto.MEAN/USD \t\u200b \tCrypto.MER/USD \t\u200b \tCrypto.MNGO/USD \tbatch_crypto_spl_3 \tCrypto.ORCA/USD \t\u200b \tCrypto.PORT/USD \t\u200b \tCrypto.RAY/USD \t\u200b \tCrypto.SBR/USD \t\u200b \tCrypto.SLND/USD \tbatch_crypto_spl_4 \tCrypto.SNY/USD \t\u200b \tCrypto.SRM/USD \t\u200b \tCrypto.ZBC/USD \tbatch_crypto_bep_1 \tCrypto.ALPACA/USD \t\u200b \tCrypto.AUTO/USD \t\u200b \tCrypto.BANANA/USD \t\u200b \tCrypto.BIFI/USD \t\u200b \tCrypto.BNX/USD \tbatch_crypto_bep_2 \tCrypto.BSW/USD \t\u200b \tCrypto.C98/USD \t\u200b \tCrypto.CAKE/USD \t\u200b \tCrypto.DAR/USD \t\u200b \tCrypto.MBOX/USD \tbatch_crypto_bep_3 \tCrypto.PINKSALE/USD \t\u200b \tCrypto.RACA/USD \t\u200b \tCrypto.SFP/USD \t\u200b \tCrypto.THG/USD \t\u200b \tCrypto.TWT/USD \tbatch_crypto_bep_4 \tCrypto.WOM/USD \t\u200b \tCrypto.XVS/USD \t\u200b \tCrypto.XWG/USD \tbatch_crypto_erc_1 \tCrypto.1INCH/USD \t\u200b \tCrypto.AAVE/USD \t\u200b \tCrypto.ALICE/USD \t\u200b \tCrypto.AMP/USD \t\u200b \tCrypto.APE/USD \tbatch_crypto_erc_2 \tCrypto.AURORA/USD \t\u200b \tCrypto.AXS/USD \t\u200b \tCrypto.BIT/USD \t\u200b \tCrypto.CEL/USD", "doc_id": "aa195a20-6c42-4962-8251-2e8e07339ddb", "embedding": null, "doc_hash": "17b6389fac341ea103ee29b043030e21d95d2a4225d21893a8bcaf2fc6b823da", "extra_info": null, "node_info": {"start": 50103, "end": 51872}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "5fa0a9ae-5171-4a8b-a4b8-fe6018aab318", "3": "e617588c-37bb-479c-adde-3554e85c5b02"}}, "__type__": "1"}, "e617588c-37bb-479c-adde-3554e85c5b02": {"__data__": {"text": "\tbatch_crypto_erc_2 \tCrypto.AURORA/USD \t\u200b \tCrypto.AXS/USD \t\u200b \tCrypto.BIT/USD \t\u200b \tCrypto.CEL/USD \t\u200b \tCrypto.CHR/USD \tbatch_crypto_erc_3 \tCrypto.COW/USD \t\u200b \tCrypto.DYDX/USD \t\u200b \tCrypto.FET/USD \t\u200b \tCrypto.FLOKI/USD \t\u200b \tCrypto.FTT/USD \tbatch_crypto_erc_4 \tCrypto.GALA/USD \t\u200b \tCrypto.LINK/USD \t\u200b \tCrypto.OMI/USD \t\u200b \tCrypto.SHIB/USD \t\u200b \tCrypto.SWEAT/USD \tbatch_crypto_erc_5 \tCrypto.THETA/USD \t\u200b \tCrypto.TLM/USD \t\u200b \tCrypto.UNI/USD \t\u200b \tCrypto.WOO/USD \tbatch_crypto_trc_1 \tCrypto.BTT/USD \t\u200b \tCrypto.JST/USD \t\u200b \tCrypto.NFT/USD \t\u200b \tCrypto.SUN/USD \t\u200b \tCrypto.WIN/USD \tbatch_crypto_cw_1 \tCrypto.ANC/USD \t\u200b \tCrypto.MIR/USD \tbatch_crypto_ht_1 \tCrypto.MDX/USD \tThe above batches were deployed in production on 22/12/2022\u2014as new feeds are created and supported on the network, those batches may become outdated. Without reorganization, any new price feed will automatically be added to an existing batch until full.\nThe Pyth Data Association and contributors to the Pyth network will do their best to keep the above table up to date.\n\n\n\n\nBenchmarks\nUse historical Pyth price data in your application\nPyth benchmarks allows users to query a historical archive of prices from Pythnet Price Feeds. For example, applications can retrieve the price of BTC/USD as of last Friday at 8:00 AM UTC. This price can be used for contract settlement or any other application that requires historical price data. Benchmarks data is signed and verifiable on-chain with the same trust assumptions as Pythnet Price Feeds.\nUsers can access benchmark prices in several different ways, depending on the use case:\nManual Browsing\nThe benchmarks page of the pyth.network website allows users to search the archive of benchmark prices. It also provides default options for common settlement dates and times. Users can select a time and see all of the Pyth prices that were active at that time. Technically, each displayed price corresponds to the Pyth price update published just before the selected time; this ensures that the displayed price is the one a user would have seen if they observed the Pyth price at that time.\nOn-chain Contracts\nOn-chain contracts can consume benchmark prices using the same on-demand model as Pythnet Price Feeds. Integrators can follow these three steps:\n      1. 1.\n      2. Use the price service endpoint /api/get_vaa to retrieve a signed price update for the desired price feed and time. This endpoint will return a signed price update, specifically the price update immediately after the queried time. This step can be done in either a web frontend or a backend process, depending on who is expected to initiate the transaction.\n      3. 2.\n      4. Pass this price update to your on-chain contract as part of the transaction that needs the benchmark data.\n      5. 3.\n      6. In your on-chain contract, pass the price", "doc_id": "e617588c-37bb-479c-adde-3554e85c5b02", "embedding": null, "doc_hash": "3815b259eb716c06e49fe39ef79c2b356541b67fb0b1c2ef2a50e69bca25eb9a", "extra_info": null, "node_info": {"start": 51909, "end": 54723}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "aa195a20-6c42-4962-8251-2e8e07339ddb", "3": "d1e42746-e062-4e35-bfa9-587191dab8c6"}}, "__type__": "1"}, "d1e42746-e062-4e35-bfa9-587191dab8c6": {"__data__": {"text": "this price update to your on-chain contract as part of the transaction that needs the benchmark data.\n      5. 3.\n      6. In your on-chain contract, pass the price update to the parsePriceFeedUpdates function on the Pyth contract. This function will check the validity of the update and return the price of the requested asset (if valid). The price update will only be valid if the signatures are correct and the update falls within a user-configured time interval; integrators should set this time interval such that it matches their desired time.\nNote that this process is similar to the standard process for consuming on-demand updates. The main differences are that users call the get_vaa endpoint instead of latest_vaas, and the on-chain contract calls parsePriceFeedUpdates instead of updatePriceFeeds. The pyth-crosschain repo has example code for an integration along the lines above for EVM chains.\n\n\n\n\nTradingView Integration\nIntegrate Pyth price feeds on your application user interface with the TradingView widget\nThe TradingView integration is a web-based widget that allows users to view Pyth prices on their own website. All Pyth prices made available through the TradingView integration are originating from Pythnet.\nTechnical Integration\n      1. 1.\n      2. Add the following script(s) from TradingView to your website depending on your framework:\nhtml\nReact\n<!-- TradingView Widget BEGIN -->\n<div class=\"tradingview-widget-container\">\n <div id=\"tradingview\"></div>\n <script\n   type=\"text/javascript\"\n   src=\"https://s3.tradingview.com/tv.js\"\n ></script>\n <script type=\"text/javascript\">\n   new TradingView.widget({\n     autosize: true,\n     symbol: \"PYTH:BTCUSD\",\n     interval: \"D\",\n     timezone: \"Etc/UTC\",\n     theme: \"light\",\n     style: \"1\",\n     locale: \"en\",\n     toolbar_bg: \"#f1f3f6\",\n     enable_publishing: false,\n     allow_symbol_change: true,\n     container_id: \"tradingview\",\n   });\n </script>\n</div>\n<!-- TradingView Widget END -->\n      1. 2.\n      2. Replace the symbol parameter with the Pyth symbol you want to display. For example, to display the price of Ethereum, use symbol: \"PYTH:ETHUSD\".\n      3. 3.\n      4. Replace the interval parameter with the time interval you want to display. For example, to display the price of Ethereum in 1-minute intervals, use interval: \"1\". Possible resolutions are daily (D or 1D, 2D ... ), weekly (1W, 2W ...), monthly (1M, 2M...) and an intra-day resolution \u2013 minutes(1, 2 ...).\n      5. 4.\n      6. Replace the timezone parameter with the timezone you want to display. For example, to display the price of Ethereum in the Eastern Time Zone, use timezone: \"America/New_York\".\n      7. 5.\n      8. Replace the theme parameter with the theme you want to display. For example, to display the price of Ethereum in dark mode, use theme:", "doc_id": "d1e42746-e062-4e35-bfa9-587191dab8c6", "embedding": null, "doc_hash": "3537992c7130c306bbdce6fd441a3626c2679ed7481857eb5a4babd826a3a67d", "extra_info": null, "node_info": {"start": 54684, "end": 57496}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "e617588c-37bb-479c-adde-3554e85c5b02", "3": "fba4ffae-ef70-46a9-8a93-e3eb58a6d81b"}}, "__type__": "1"}, "fba4ffae-ef70-46a9-8a93-e3eb58a6d81b": {"__data__": {"text": "     7. 5.\n      8. Replace the theme parameter with the theme you want to display. For example, to display the price of Ethereum in dark mode, use theme: \"dark\".\n      9. 6.\n      10. There is a fully working open-source example of the TradingView integration by one of Pyth's contributors here. The example application is deployed here.\n\n\n\n\nPublish Data\nGet started publishing data\nData providers can get started publishing data to the Pyth Network by performing the following steps.\nRequest access\nFirst, contact the Pyth Data Association and request to become a data provider. You can reach out on Discord or Telegram. Only data providers with first-party data (exchanges, market makers, and trading firms) are allowed to participate in the network.\nGenerate keypair\nEvery data provider is identified on the network by a public key, and their prices are signed by the corresponding private key. You will need a Solana public/private key pair for this purpose. If you do not already have a keypair, you can create one using the instructions below:\n# Install the Solana Tool Suite, needed for creating the key used to sign your transactions.\n# See https://docs.solana.com/cli/install-solana-cli-tools for the latest version\nsh -c \"$(curl -sSfL https://release.solana.com/v1.14.13/install)\"\n\u200b\n# Generate a public/private keypair.\nsolana-keygen new --no-bip39-passphrase --outfile publish_key_pair.json\nThis command will create a public/private keypair in publish_key_pair.json. Please extract the public key from this file and share it with the Pyth Data Association so they can enable you to publish prices.\n# Print the public key of the keypair.\nsolana-keygen pubkey publish_key_pair.json\nThis command will output the public key in base58 encoding and will look something like:\n5rYvdyWAunZgD2EC1aKo7hQbutUUnkt7bBFM6xNq2z7Z\nMost data providers choose to generate two separate keypairs, one for testing and one for production. If you do so, please share both public keys with the Pyth Data Association.\nProcure validators\nEvery data provider to the network will require both a Solana RPC node and a Pythnet validator. The Pyth Data Association will assist you with this step.\nPyth-agent\nData providers can publish data to the network using the pyth-agent software package. This package abstracts away all of the communication with the underlying blockchain and exposes a simple JSON RPC interface for submitting price data. Please see the README of that package for instructions on using it. This software requires you to configure both the keypair and validators from the previous steps in order to run. Please also see the JSON RPC API documentation. Finally, the example publisher is a fully-worked example of how to integrate with the pyth-agent API.\n\n\n\n\nUnderstanding Publishing Slots\nWhen a quoter publishes a price, the pyth-client API also forwards what it thinks is the current slot on Solana and Pythnet. This is known as its publishing slot.\nThe publishing slot and price is stored as the latest update for that publisher on-chain but only if the price is for a later slot than that currently stored. This is to prevent prices from being updated out-of-order and to facilitate arbitration between multiple publishers.\nThe aggregation algorithm only", "doc_id": "fba4ffae-ef70-46a9-8a93-e3eb58a6d81b", "embedding": null, "doc_hash": "a9f72d47c3878794d6ec315d306d310676fb1561741728e15bdc1c56fc4c87fc", "extra_info": null, "node_info": {"start": 57507, "end": 60767}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "d1e42746-e062-4e35-bfa9-587191dab8c6", "3": "aa163b6f-86af-45ec-9687-40e2a25d5020"}}, "__type__": "1"}, "aa163b6f-86af-45ec-9687-40e2a25d5020": {"__data__": {"text": "if the price is for a later slot than that currently stored. This is to prevent prices from being updated out-of-order and to facilitate arbitration between multiple publishers.\nThe aggregation algorithm only combines prices from publishers that were published within 25 slots of the current on-chain slot.\nNot all published prices get included in the pyth contract due to unreliable transports and the way Solana and Pythnet formulate and reach consensus on each slot.\nA quoter may detect if a published price is dropped by comparing the list of publishing slots it submits vs what it subsequently receives in each aggregate price callback.\nFor example, here is an excerpt of a log take from a run of the test_publish.cpp example program against mainnet-beta. It logs everything it sends and everything it receives.\nThe publishing slots of six consecutive price submissions have been annotated with the labels A, B, C, D, E and F or slots 79018079, 79018084, 79018085, 79018086, 79018087, 79018092.\nThe API submits a new price every time it receives notification of a new slot but note that prices for slots 79018080 thru 79018083 and 79018088 thru 79018091 were not submitted. This is because solana does not always publish consecutive slots and gaps can occur. Solana can also publish slots out-of-order, but the API ignores these and is guaranteed only to issue callbacks for slots that are strictly increasing.\nPrice updates occur for slots labelled A, B, C and F. Slots D and E (79018086, 79018087) were dropped and did not get executed on the chain.\nThe API keeps track of the \"hit-rate\" of price submissions that show up in the update callbacks and tracks end-to-end latency statistics at the 25th, 50th, 75th and 99th percentiles both in terms of seconds of elapsed time and in number of slot updates observed. For example, from the same log:The API keeps track of the \"hit-rate\" of price submissions that show up in the update callbacks and tracks end-to-end latency statistics at the 25th, 50th, 75th and 99th percentiles both in terms of seconds of elapsed time and in number of slot updates observed. For example, from the same log:\n\n\npyth-client Websocket API\n\u200bpyth-agent supports a websocket interface based on the json-rpc 2.0 standard. Methods include:\n      * \u200bget_product_list\u200b\n      * \u200bupdate_price\u200b\n      * \u200bsubscribe_price_sched\u200b\n      * \u200bget_product\u200b\n      * \u200bget_all_products\u200b\nBatch requests are processed in the order the requests appear within the batch.\nget_product_list\nGet the list of available symbols and associated metadata.\nPlease note that all of the fields in the attr_dict dictionary should be considered optional: your publishing software should gracefully handle cases where any of these fields are missing.\nThe request looks like:\n{\n \"jsonrpc\": \"2.0\",\n \"method\": \"get_product_list\",\n \"id\" : 1\n}\nA successful response looks something like:\n{\n\"jsonrpc\": \"2.0\",\n\"result\": [\n {\n  \"account\":", "doc_id": "aa163b6f-86af-45ec-9687-40e2a25d5020", "embedding": null, "doc_hash": "b11a8a7413ecf1451fce02fcf43dec1b71d919663262eb2c84a5aac0976ec7cb", "extra_info": null, "node_info": {"start": 60708, "end": 63633}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "fba4ffae-ef70-46a9-8a93-e3eb58a6d81b", "3": "fadaf1d9-30e5-4131-aba4-30c9cbb2111d"}}, "__type__": "1"}, "fadaf1d9-30e5-4131-aba4-30c9cbb2111d": {"__data__": {"text": "\"get_product_list\",\n \"id\" : 1\n}\nA successful response looks something like:\n{\n\"jsonrpc\": \"2.0\",\n\"result\": [\n {\n  \"account\": \"9F6eBgAfktth93C9zmtKDXFXNjZkq6JwJR56VPKqWmJm\",\n  \"attr_dict\": {\n   \"symbol\": \"SYMBOL1/USD\",\n   \"asset_type\": \"Equity\",\n   \"country\": \"USA\",\n   \"description\": \"pyth example product #1\",\n   \"quote_currency\": \"USD\",\n   \"tenor\": \"Spot\",\n   \"cms_symbol\": \"SYMBOL1\",\n   \"cqs_symbol\": \"SYMBOL1\",\n   \"nasdaq_symbol\": \"SYMBOL1\"\n  },\n  \"price\": [\n   {\n    \"account\": \"CrZCEEt3awgkGLnVbsv45Pp4aLhr7fZfZr3ubzrbNXaq\",\n    \"price_exponent\": -4,\n    \"price_type\": \"price\"\n   }\n  ]\n },\n {\n  \"account\": \"HCFaDYyz1ajS57HfCaaqzA1cZSaa2oEccQejbHaaofd4\",\n  \"attr_dict\": {\n   \"symbol\": \"SYMBOL2/USD\",\n   \"asset_type\": \"Equity\",\n   \"country\": \"USA\",\n   \"description\": \"pyth example product #2\",\n   \"quote_currency\": \"USD\",\n   \"tenor\": \"Spot\",\n   \"cms_symbol\": \"SYMBOL2\",\n   \"cqs_symbol\": \"SYMBOL2\",\n   \"nasdaq_symbol\": \"SYMBOL2\"\n  },\n  \"price\": [\n   {\n    \"account\": \"7FUsKvvtN5rB1fgYFWZLo5DLcqHTTeu63bUPThYT6MiS\",\n    \"price_exponent\": -4,\n    \"price_type\": \"price\"\n   }\n  ]\n }\n],\n\"id\": null\n}\nupdate_price\nUpdate component price of some symbols using the publishing key of pyth-agent.\nThe request includes the pricing account from the get_product_list output and looks something like:\n{\n \"jsonrpc\": \"2.0\",\n \"method\": \"update_price\",\n \"params\" : {\n   \"account\": \"CrZCEEt3awgkGLnVbsv45Pp4aLhr7fZfZr3ubzrbNXaq\",\n   \"price\" : 42002,\n   \"conf\" : 3,\n   \"status\": \"trading\"\n },\n \"id\" : 1\n}\nThe price and confidence interval (conf) attributes are expressed as integers with an implied decimal point given by the price_exponent defined by the symbol. The price type is a string with one of the following values: \"price\" or \"ema__price\". The symbol status is a string with one of the following values: \"trading\" or \"halted\".\nA successful response looks like:\n{\n \"jsonrpc\": \"2.0\",\n \"result\" : 0,\n \"id\" : 1\n}\nsubscribe_price_sched\nSubscribe to price update schedule. pyth-agent will notify the client whenever it should", "doc_id": "fadaf1d9-30e5-4131-aba4-30c9cbb2111d", "embedding": null, "doc_hash": "e2e78d1b05f5fd8cd4c77d60de99150b7993b389a81baae353592f086eddb075", "extra_info": null, "node_info": {"start": 63702, "end": 65713}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "aa163b6f-86af-45ec-9687-40e2a25d5020", "3": "80236cbc-10c1-4400-91ab-6ce0b2b42e18"}}, "__type__": "1"}, "80236cbc-10c1-4400-91ab-6ce0b2b42e18": {"__data__": {"text": "\"2.0\",\n \"result\" : 0,\n \"id\" : 1\n}\nsubscribe_price_sched\nSubscribe to price update schedule. pyth-agent will notify the client whenever it should submit the next price for a subscribed symbol.\nThe request looks like:\n{\n \"jsonrpc\": \"2.0\",\n \"method\": \"subscribe_price_sched\",\n \"params\" : {\n   \"account\": \"CrZCEEt3awgkGLnVbsv45Pp4aLhr7fZfZr3ubzrbNXaq\",\n },\n \"id\" : 1\n}\nA successful response looks like:\n{\n \"jsonrpc\": \"2.0\",\n \"result\" : {\n   \"subscription\" : 1234\n },\n \"id\" : 1\n}\nWhere the result is an integer corresponding to a subscription identifier. All subsequent notifications for this subscription correspond to this identifier.\n{\n \"jsonrpc\": \"2.0\",\n \"method\": \"notify_price_sched\",\n \"params\": {\n   \"subscription\" : 1234\n }\n}\nget_product\nGet the full set of data for the given product.\nPlease note that all of the fields in the attr_dict dictionary should be considered optional: your publishing software should gracefully handle cases where any of these fields are missing.\nThe request looks like:\n{\n \"jsonrpc\": \"2.0\",\n \"method\": \"get_product\",\n \"params\": {\n   \"account\": \"4aDoSXJ5o3AuvL7QFeR6h44jALQfTmUUCTVGDD6aoJTM\"\n },\n \"id\" : 1\n}\nA successful response looks something like:\n{\n \"jsonrpc\": \"2.0\",\n \"result\": {\n   \"account\": \"4aDoSXJ5o3AuvL7QFeR6h44jALQfTmUUCTVGDD6aoJTM\",\n   \"attr_dict\": {\n     \"asset_type\": \"Crypto\",\n     \"symbol\": \"BTC/USD\",\n     \"country\": \"US\",\n     \"quote_currency\": \"USD\",\n     \"description\": \"BTC/USD\",\n     \"tenor\": \"Spot\",\n     \"generic_symbol\": \"BTCUSD\"\n   },\n   \"price_accounts\": [\n     {\n       \"account\": \"GVXRSBjFk6e6J3NbVPXohDJetcTjaeeuykUpbQF8UoMU\",\n       \"price_type\": \"price\",\n       \"price_exponent\": -8,\n       \"status\": \"trading\",\n       \"price\": 4426101900000,\n       \"conf\": 4271150000,\n       \"ema_price\": 4433467600000,\n       \"ema_confidence\": 1304202670,\n       \"valid_slot\": 91402257,\n       \"pub_slot\": 91402259,\n       \"prev_slot\": 91402256,\n       \"prev_price\": 4425895500000,\n       \"prev_conf\": 3315350000,\n       \"publisher_accounts\": [\n         {\n    ", "doc_id": "80236cbc-10c1-4400-91ab-6ce0b2b42e18", "embedding": null, "doc_hash": "696ad9cfb02f2509d6da8d7f3302f29ab2229b8e8dc7005d22d35e49f2648182", "extra_info": null, "node_info": {"start": 65698, "end": 67710}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "fadaf1d9-30e5-4131-aba4-30c9cbb2111d", "3": "b90c93b6-3826-4f4d-ac89-15d0c185651d"}}, "__type__": "1"}, "b90c93b6-3826-4f4d-ac89-15d0c185651d": {"__data__": {"text": "      \"prev_conf\": 3315350000,\n       \"publisher_accounts\": [\n         {\n           \"account\": \"HekM1hBawXQu6wK6Ah1yw1YXXeMUDD2bfCHEzo25vnEB\",\n           \"status\": \"trading\",\n           \"price\": 4426958500000,\n           \"conf\": 1492500000,\n           \"slot\": 91402255\n         },\n         {\n           \"account\": \"GKNcUmNacSJo4S2Kq3DuYRYRGw3sNUfJ4tyqd198t6vQ\",\n           \"status\": \"trading\",\n           \"price\": 4424690000000,\n           \"conf\": 3690000000,\n           \"slot\": 91402256\n         }\n       ]\n     }\n   ]\n },\n \"id\": 1\n}\nget_all_products\nGet full set of data for the given product.\nPlease note that all of the fields in the attr_dict dictionary should be considered optional: your publishing software should gracefully handle cases where any of these fields are missing.\nThe request looks like:\n{\n \"jsonrpc\": \"2.0\",\n \"method\": \"get_all_products\",\n \"id\" : 1\n}\nA successful response looks something like:\n{\n \"jsonrpc\": \"2.0\",\n \"result\": [\n   {\n     \"account\": \"5uKdRzB3FzdmwyCHrqSGq4u2URja617jqtKkM71BVrkw\",\n     \"attr_dict\": {\n       \"asset_type\": \"Crypto\",\n       \"symbol\": \"BCH/USD\",\n       \"country\": \"US\",\n       \"quote_currency\": \"USD\",\n       \"description\": \"BCH/USD\",\n       \"tenor\": \"Spot\",\n       \"generic_symbol\": \"BCHUSD\"\n     },\n     \"price_accounts\": [\n       {\n         \"account\": \"5ALDzwcRJfSyGdGyhP3kP628aqBNHZzLuVww7o9kdspe\",\n         \"price_type\": \"price\",\n         \"price_exponent\": -8,\n         \"status\": \"trading\",\n         \"price\": 60282000000,\n         \"conf\": 26000000,\n         \"ema_price\": 60321475000,\n         \"ema_confidence\": 22504746,\n         \"valid_slot\": 91402601,\n         \"pub_slot\": 91402604,\n        ", "doc_id": "b90c93b6-3826-4f4d-ac89-15d0c185651d", "embedding": null, "doc_hash": "632028c6284243c5b59285a98160bd23d2f609c25ed676b30e276a1ac823bf94", "extra_info": null, "node_info": {"start": 67788, "end": 69439}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "80236cbc-10c1-4400-91ab-6ce0b2b42e18", "3": "082929e3-9ddb-483a-9176-0262053f108b"}}, "__type__": "1"}, "082929e3-9ddb-483a-9176-0262053f108b": {"__data__": {"text": "        \"valid_slot\": 91402601,\n         \"pub_slot\": 91402604,\n         \"prev_slot\": 91402600,\n         \"prev_price\": 60282000000,\n         \"prev_conf\": 26000000,\n         \"publisher_accounts\": [\n           {\n             \"account\": \"HekM1hBawXQu6wK6Ah1yw1YXXeMUDD2bfCHEzo25vnEB\",\n             \"status\": \"trading\",\n             \"price\": 60282000000,\n             \"conf\": 26000000,\n             \"slot\": 91402599\n           },\n           {\n             \"account\": \"2V7t5NaKY7aGkwytCWQgvUYZfEr9XMwNChhJEakTExk6\",\n             \"status\": \"unknown\",\n             \"price\": 0,\n             \"conf\": 0,\n             \"slot\": 0\n           }\n         ]\n       }\n     ]\n   },\n   {\n     \"account\": \"3nuELNFBkbXqsXtnCzphRPCX6toKKYxVDnkyr9pTwB1K\",\n     \"attr_dict\": {\n       \"asset_type\": \"Crypto\",\n       \"symbol\": \"SABER/USD\",\n       \"country\": \"US\",\n       \"quote_currency\": \"USD\",\n       \"description\": \"SABER/USD\",\n       \"tenor\": \"Spot\",\n       \"generic_symbol\": \"SABERUSD\"\n     },\n     \"price_accounts\": [\n       {\n         \"account\": \"8Td9VML1nHxQK6M8VVyzsHo32D7VBk72jSpa9U861z2A\",\n         \"price_type\": \"price\",\n         \"price_exponent\": -8,\n         \"status\": \"trading\",\n         \"price\": 5785000,\n         \"conf\": 5000,\n         \"ema_price\": 5856365,\n         \"ema_confidence\": 10241,\n         \"valid_slot\": 91402601,\n         \"pub_slot\": 91402604,\n         \"prev_slot\": 91402600,\n         \"prev_price\": 5785000,\n", "doc_id": "082929e3-9ddb-483a-9176-0262053f108b", "embedding": null, "doc_hash": "ffd3caa92c11f459ae5fa6915861135e02af7fa335f2acfa0a7ed0d7dc4921ba", "extra_info": null, "node_info": {"start": 69445, "end": 70854}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "b90c93b6-3826-4f4d-ac89-15d0c185651d", "3": "09b0d1da-a63f-429b-8c9d-497a387df3a5"}}, "__type__": "1"}, "09b0d1da-a63f-429b-8c9d-497a387df3a5": {"__data__": {"text": "  \"pub_slot\": 91402604,\n         \"prev_slot\": 91402600,\n         \"prev_price\": 5785000,\n         \"prev_conf\": 5000,\n         \"publisher_accounts\": [\n           {\n             \"account\": \"GKNcUmNacSJo4S2Kq3DuYRYRGw3sNUfJ4tyqd198t6vQ\",\n             \"status\": \"trading\",\n             \"price\": 5785000,\n             \"conf\": 5000,\n             \"slot\": 91402601\n           }\n         ]\n       }\n     ]\n   }\n ],\n \"id\": 1\n}\n\n\n\n\nConfidence Interval and Crypto Exchange Fees\nIt is very important that publishers consider crypto exchange aggressive fees when calculating their price and confidence intervals from one or more exchange order books. Ask prices should be moved up by the best publicly available aggressive fee rate, and bid prices should be moved down by the same rate.\nask_adjusted = ask * (1.0 + fee_rate)\nbid_adjusted = bid * (1.0 - fee_rate)\nThis is to reflect the \"after fee\" effective prices that could be gotten on that exchange. This is important for crypto markets because the fees are often MUCH larger than the typical bid-ask spread. It is not important for other markets (such as US equities) where fees are small compared with the bid-ask spread. The rationale for this adjustment is that the \"fair price\" could be above the best ask or below the best bid by as much as the aggressive fees before an informed trader would be able to profitably trade on this exchange and move the best price. Because of that, the best price on the exchange could be \"wrong\" by as much as +/- the aggressive fees.\nExample 1 - Exchange A has best aggressive fee of 10bps\n  \n\nExchange A should publish a price of $50,000.01 and a confidence of $50.005 (half the bid-ask spread after fee adjustment). It would be wrong to publish a confidence of $0.005 based on the \"not fee-adjusted\" raw exchange bid-ask spread.\nExample 2 - Exchange A has a best aggressive fee of 10bps. Exchange B has a best aggressive fee of 1bps, and a publisher is combining them into a single combined book. Exchange books are combined by taking the best ask across both exchanges and the best bid across both exchanges.\n  \n\nIn this example, if a publisher were combining the books of Exchange A and Exchange B to get a combined price, they should publish a price of $49,978.13 and confidence of $28.125, which corresponds to the midprice and half the bid-ask spread of the combined fee-adjusted books. It would be wrong to publish a price of $50,000.01 and confidence of $0.01 based on the \"not fee-adjusted\" raw exchange prices. Note that in this example, not only is the confidence changed by including the exchange fees, but the price reported is also substantially different once fees are properly accounted for.\n\n\n\n\nHow Pyth Works\nPyth is a protocol that allows market participants to", "doc_id": "09b0d1da-a63f-429b-8c9d-497a387df3a5", "embedding": null, "doc_hash": "2aea75dffd971175936e1a3de5f2e72871f3b8580fb501b9148e38d0cd2d28c0", "extra_info": null, "node_info": {"start": 70834, "end": 73593}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "082929e3-9ddb-483a-9176-0262053f108b", "3": "fe2f781c-d5d9-4740-8f15-de2884c23b82"}}, "__type__": "1"}, "fe2f781c-d5d9-4740-8f15-de2884c23b82": {"__data__": {"text": "changed by including the exchange fees, but the price reported is also substantially different once fees are properly accounted for.\n\n\n\n\nHow Pyth Works\nPyth is a protocol that allows market participants to publish pricing information on-chain for others to use. The protocol is an interaction between three parties:\n      1. 1.\n      2. Publishers submit pricing information to Pyth's oracle program. Pyth has multiple data publishers for every product to improve the accuracy and robustness of the system.\n      3. 2.\n      4. Pyth's oracle program combines publishers' data to produce a single aggregate price and confidence interval.\n      5. 3.\n      6. Consumers read the price information produced by the oracle program.\nPyth's oracle program runs simultaneously on both Solana mainnet and Pythnet. Each instance of the program is responsible for its own set of price feeds. Solana Price Feeds are available for use by Solana protocols. In this case, since the oracle program itself runs on Solana, the resulting prices are immediately available to consumers without requiring any additional work. Pythnet Price Feeds are available on 12+ blockchains. The prices constructed on Pythnet are transferred cross-chain to reach consumers on these blockchains.\nIn both cases, the critical component of the system is the oracle program that combines the data from each individual publisher. This program maintains a number of different Solana accounts that list the products on Pyth and their current price data. Publishers publish their price and confidence by interacting with the oracle program on every slot. The program stores this information in its accounts. The first price update in a slot additionally triggers price aggregation, which combines the price data from the previous slot into a single aggregate price and confidence interval. This aggregate price is written to the Solana account where it is readable by other on-chain programs and available for transmission to other blockchains.\n\n\n\n\nPythnet\nPythnet is an application-specific blockchain operated by Pyth's data providers. This blockchain is a computation substrate to securely combine the data provider's prices into a single aggregate price for each Pyth price feed. Pythnet forms the core of Pyth's off-chain price feeds that serve all blockchains (except Solana mainnet).\nPythnet is powered by Solana technology: it runs the same validator software, but is a separate network that is specially configured to be a proof-of-authority chain. The network depends on a tightly controlled supply of the chain's native token, called PGAS, which is currently controlled by the Pyth Data Association. Operating a validator on the network requires a large stake of PGAS tokens. The Pyth Data Association allows each data provider to operate one validator by delegating them the necessary stake. Each data provider is then given a sufficient quantity of PGAS tokens to publish prices to the network. The network is configured such that account creation is very expensive, preventing anyone without a substantial quantity of PGAS from deploying programs to the network. Once governance is live, it will take over management of the PGAS token from the Pyth Data Association.\nThe purpose of Pythnet is to provide a secure and reliable computing substrate for Pyth's price aggregation. Recall that Pyth's data providers submit their own price quotes for each product. The Pyth protocol needs to be able to combine these prices to produce a single aggregate price. This computation needs to be performed securely -- prices must", "doc_id": "fe2f781c-d5d9-4740-8f15-de2884c23b82", "embedding": null, "doc_hash": "a47935b6ad121cea8adcdf14f8548be5273029d4c3caf27e3893dd4777c49c4a", "extra_info": null, "node_info": {"start": 73483, "end": 77070}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "09b0d1da-a63f-429b-8c9d-497a387df3a5", "3": "250f0d04-b83d-4aa2-acb8-994b377d5c22"}}, "__type__": "1"}, "250f0d04-b83d-4aa2-acb8-994b377d5c22": {"__data__": {"text": "submit their own price quotes for each product. The Pyth protocol needs to be able to combine these prices to produce a single aggregate price. This computation needs to be performed securely -- prices must be combined correctly -- and reliably -- prices must always be available for applications. Pythnet solves both of these problems. First, anyone can validate that the price computation is done correctly by replaying the network's transaction log. The Wormhole guardians perform this validation when constructing the Pyth price update messages that are delivered to other blockchains. Consequently, as long as 2/3+ of the Wormhole guardians are honest, users of Pyth prices can trust that they were computed accurately. Second, the Pythnet blockchain has built-in redundancy to ensure high availability: it is operational as long as 2/3+ of Pythnet validators are online. Furthermore, Pythnet remains available even when target chain transaction bandwidth is highly contested, such as during periods of high market volatility.\n\n\n\n\nCross-chain\nPyth uses a cross-chain mechanism to transfer prices from Pythnet to target chains. The diagram below shows how prices are delivered from Pythnet to target chains:\n  \n\nData providers publish their prices on Pythnet. The on-chain oracle program then aggregates prices for a feed to obtain the aggregate price and confidence. Next, the attester program regularly attests to the most recently observed Pyth prices and creates a Wormhole message to be sent to the Wormhole contract on Pythnet. The Wormhole guardians then observe the attestation message and create a signed VAA for the message.\nThe price service API continually listens to Wormhole for Pyth price update messages. It stores the latest update message in memory and exposes HTTP and websocket APIs for retrieving the latest update. (Anyone can run an instance of this webservice, but the Pyth Data Association runs a public instance for convenience.) When a user wants to use a Pyth price in a transaction, they retrieve the latest update message (a signed VAA) from the price service and submit it in their transaction. The target chain Pyth contract will verify the validity of the price update message and, if it is valid, store the new price in its on-chain storage. See on-demand updates for more details about this process.\nFinally, on-chain protocols integrate with the Pyth contract via a simple API that retrieves the current Pyth price from its on-chain storage. This API will return the current price as long as it has been updated sufficiently recently; this approach works because users will have updated the Pyth price earlier in the same transaction. Protocols can configure the recency threshold to suit their needs \u2014 e.g., latency sensitive applications can set a lower threshold than the default.\n\n\n\n\nOracle Program\nThe oracle program is responsible for several tasks:\n      1. 1.\n      2. Maintaining the set of price feeds.\n      3. 2.\n      4. Storing the contributions of data providers to each price feed.\n      5. 3.\n      6. Combining the individual data providers' prices into a single aggregate price and confidence interval.\n      7. 4.\n      8. Performing any additional stateful computations on the resulting price series, such as computing moving averages.\nThe oracle solves these problems by maintaining a collection of Solana accounts to represent the set of price feeds.", "doc_id": "250f0d04-b83d-4aa2-acb8-994b377d5c22", "embedding": null, "doc_hash": "82f4e7083630786a6adc44a09fe3ff9aa3eaa136f29de80fae87e8078ce25b93", "extra_info": null, "node_info": {"start": 77075, "end": 80488}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "fe2f781c-d5d9-4740-8f15-de2884c23b82", "3": "bb5c5c3f-a708-4802-bf73-de1b66cad1dc"}}, "__type__": "1"}, "bb5c5c3f-a708-4802-bf73-de1b66cad1dc": {"__data__": {"text": "stateful computations on the resulting price series, such as computing moving averages.\nThe oracle solves these problems by maintaining a collection of Solana accounts to represent the set of price feeds. Each feed has two accounts: a product account to store metadata and a price account. The price account stores a list of authorized data providers for this specific price feed, and allocates storage space for each data provider's price. The oracle program exposes an instruction called upd_price that enables an authorized data provider to update the price account with their current estimate of the price and confidence interval. Additionally, the first time that upd_price is called in a slot, it will aggregate the individual data provider's prices into an aggregate price and confidence interval. Only the aggregate price and confidence are made available for use in downstream applications; the individual data providers prices are internal state of the oracle program. Finally, the oracle program computes an exponentially-weighted moving average of the oracle price.\n\n\n\n\nAccount Structure\nThe Pyth oracle program manages a number of on-chain accounts. There are three different types of accounts:\n      1. 1.\n      2. Product accounts store metadata about a product, such as its symbol (e.g., \"BTC/USD\") and asset type.\n      3. 2.\n      4. Price accounts store the current price information for a particular product. This account has fields such as the current price, a confidence interval, an exponential moving average price, an exponential moving average confidence interval and whether or not a price is currently available.\n      5. 3.\n      6. Mapping accounts serve as a listing of other accounts. The mapping accounts are organized into a linked list whose values are the set of product accounts. These accounts allow applications to enumerate the full list of products whose prices are available on Pyth.\nThe Pyth Rust SDK contains a sample application that prints the current content of all Pyth accounts. We will use the output of this application to better understand the content of these accounts.\nProduct Accounts\nProduct accounts store metadata about a product. This metadata is represented as a set of reference attributes, stored as a list of text key/value pairs. Not all product accounts follow the same structure; for a comprehensive overview, visit the Product Metadata page. For example, the product account for AAPL contains the following fields:\nproduct_account .. G89jkM5wFLpmnbvRbeePUumxsJyzoXaRfgBVjyx2CPzQ\n symbol.......... Equity.US.AAPL/USD\n asset_type...... Equity\n quote_currency.. USD\n description..... APPLE INC\n base............ AAPL\n country......... US\n cms_symbol...... AAPL\n cqs_symbol...... AAPL\n nasdaq_symbol... AAPL\n price_account... CqFJLrT4rSpA46RQkVYWn8tdBDuQ7p7RXcp6Um76oaph\nThis snippet shows the reference attributes for AAPL. The set of available reference attributes depends on the asset_type. Every product account has symbol , asset_type, quote_currency , and price_account . US equity products additionally include additional reference symbology that is useful for mapping Pyth products to other industry-standard identifiers. The product account also contains a pointer to a price account that contains the product's current pricing information.\nAs another example, here is the product account for BTC/USD:\nproduct_account ..", "doc_id": "bb5c5c3f-a708-4802-bf73-de1b66cad1dc", "embedding": null, "doc_hash": "1bf0c6b0512c8288705ddd4e2849d47e616437aa6a5cb3ecf0a000df57f410ce", "extra_info": null, "node_info": {"start": 80486, "end": 83878}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "250f0d04-b83d-4aa2-acb8-994b377d5c22", "3": "1037f5d7-eb09-4b7d-a13f-46b456441ab0"}}, "__type__": "1"}, "1037f5d7-eb09-4b7d-a13f-46b456441ab0": {"__data__": {"text": "industry-standard identifiers. The product account also contains a pointer to a price account that contains the product's current pricing information.\nAs another example, here is the product account for BTC/USD:\nproduct_account .. 3m1y5h2uv7EQL3KaJZehvAJa4yDNvgc5yAdL9KPMKwvk\n symbol.......... Crypto.BTC/USD\n asset_type...... Crypto\n quote_currency.. USD\n description..... BTC/USD\n generic_symbol.. BTCUSD\n base............ BTC\n price_account .. HovQMDrbAgAYPCmHVSrezcSmkMtXSSUsLDFANExrZh2J\nPrice Accounts\nPrice accounts store the current price of a product along with additional useful information. For example, consider the following content of AAPL's price account:\nprice_account .. CqFJLrT4rSpA46RQkVYWn8tdBDuQ7p7RXcp6Um76oaph\n   price ........ 16297000 x 10^-5\n   conf ......... 27952 x 10^-5\n   price_type ... price\n   exponent ..... -5\n   status ....... trading\n   corp_act ..... nocorpact\n   num_qt ....... 2\n   valid_slot ... 110430111\n   publish_slot . 110430112\n   ema_price ......... 16247409 x 10^-5\n   ema_confidence ......... 19415 x 10^-5\nThis account stores the current price in a fixed-point format. The price is computed by taking the price field and multiplying by 10^exponent. The account also includes a confidence interval that represents Pyth's uncertainty about the current price. This confidence interval can be interpreted as the standard deviation of a Laplace distribution centered around the price. conf is also stored in the same fixed-point format. In the example above, the price is 12276250, the conf is 1500 and the exponent is -5. These values translate into a price of $122.76250 +- 0.015.\nPrice accounts include several other useful fields. First, each account has a status that indicates whether or not the price is valid. Pricing information for a product can be unavailable for various reasons, for example, US equity markets only trade during certain hours. The status field indicates whether or not Pyth currently has a price for the product. Only prices with a value of status=trading should be used. If the status is not trading but is Unknown, Halted or Auction the Pyth price can be an arbitrary value.\nMapping Accounts\nMapping accounts serve as an index of the pricing information currently available on Pyth. These accounts are organized into a linked list whose values are product accounts. Applications can traverse this linked list to enumerate all products currently available on Pyth.\n\n\nEach mapping account contains a list of product account ids, plus an optional pointer to the subsequent mapping account. Each product account in turn points to the price account that stores the current price information for that product.Each mapping account contains a list of product account ids, plus an optional pointer to the subsequent mapping account. Each product account in turn points to the price account that stores the current price information for that product.\n\n\nProduct Metadata\nProduct accounts store metadata about a product. This metadata is represented as a set of reference attributes, stored as a list of text key/value pairs but not all products share the same account structure.\nEvery product has product_account, symbol, asset_type, quote_currency, base and price_account. However, the remaining fields of a product account will depend on its asset_type.\nEquity\nAs", "doc_id": "1037f5d7-eb09-4b7d-a13f-46b456441ab0", "embedding": null, "doc_hash": "f79bc9737a629fb0a717e8eefa04323f42b4faf414d8800e46374f329d91c76e", "extra_info": null, "node_info": {"start": 83853, "end": 87183}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "bb5c5c3f-a708-4802-bf73-de1b66cad1dc", "3": "7b67bb4d-f238-431d-9e9e-0c1b933a5fe8"}}, "__type__": "1"}, "7b67bb4d-f238-431d-9e9e-0c1b933a5fe8": {"__data__": {"text": "product has product_account, symbol, asset_type, quote_currency, base and price_account. However, the remaining fields of a product account will depend on its asset_type.\nEquity\nAs a rule, all products with asset_type = Equity will follow the below Product Account structure:\nproduct_account... Solana Account\n symbol.......... AssetType.Country.BaseCurrency/QuoteCurrency\n asset_type...... AssetType\n quote_currency.. QuoteCurrency\n description..... Description\n base............ BaseCurrency\n country......... Country\n cms_symbol...... NYSESymbol\n cqs_symbol...... SIPSSymbol\n nasdaq_symbol... ComstockSymbol\n price_account... Solana Account\nsymbol: AssetType.Country.BaseCurrency/QuoteCurrency where the base: BaseCurrency is, in order of availability:\n      1. 1.\n      2. cms_symbol: NYSESymbol\n      3. 2.\n      4. cqs_symbol: SIPSSymbol\n      5. 3.\n      6. nasdaq_symbol: ComstockSymbol\nHere is a snapshot of the Apple product account:\nproduct_account .. G89jkM5wFLpmnbvRbeePUumxsJyzoXaRfgBVjyx2CPzQ\n symbol.......... Equity.US.AAPL/USD\n asset_type...... Equity\n quote_currency.. USD\n description..... APPLE INC\n base............ AAPL\n country......... US\n cms_symbol...... AAPL\n cqs_symbol...... AAPL\n nasdaq_symbol... AAPL\n price_account... CqFJLrT4rSpA46RQkVYWn8tdBDuQ7p7RXcp6Um76oaph\nCrypto\nAs a rule, all products with asset_type = Crypto will follow the below Product Account structure:\nproduct_account .. Solana Account\n symbol.......... AssetType.BaseCurrency/QuoteCurrency\n asset_type...... AssetType\n quote_currency.. QuoteCurrency\n description..... Description\n generic_symbol.. JLQDSymbol\n base............ BaseCurrency\n price_account .. Solana Account\nHere is a snapshot of the Luna product account:\nproduct_account .. 25tCF4ChvZyNP67xwLuYoAKuoAcSV13xrmP9YTwSPnZY\n symbol.......... Crypto.LUNA/USD\n asset_type...... Crypto\n quote_currency.. USD\n description..... LUNA/USD\n generic_symbol.. LUNAUSD\n base............ LUNA\n price_account .. 8PugCXTAHLM9kfLSQWe2njE5pzAgUdpPk3Nx5zSm7BD3\nForeign Currency & Metal\nLastly, are Foreign Currencies (FX) and Metal assets. Those 2 asset_type share a common product account structure that follows the below template:\nproduct_account .. Solana Account\n symbol.......... AssetType.BaseCurrency/QuoteCurrency\n asset_type...... AssetType \n quote_currency.. QuoteCurrency\n description..... Description \n generic_symbol.. JLQDSymbol \n base............ BaseCurrency\n tenor........... Maturity \n price_account .. Solana Account\nHere is a snapshot of the Japanese Yen product account:\nproduct_account .. CiTV5gD8G53M1EQdo32jy5riYRU8fMFSVWC5wJj3vjcr\n symbol.......... FX.USD/JPY\n asset_type...... FX\n quote_currency.. JPY\n", "doc_id": "7b67bb4d-f238-431d-9e9e-0c1b933a5fe8", "embedding": null, "doc_hash": "eda0bfa8cc3fdfbfa0e4c3356bec95a5459b2c5a9e22aaf11688341621a4231b", "extra_info": null, "node_info": {"start": 87226, "end": 89898}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "1037f5d7-eb09-4b7d-a13f-46b456441ab0", "3": "e98fca98-9ddb-4de8-87ad-c0ac568c230f"}}, "__type__": "1"}, "e98fca98-9ddb-4de8-87ad-c0ac568c230f": {"__data__": {"text": "symbol.......... FX.USD/JPY\n asset_type...... FX\n quote_currency.. JPY\n description..... USD/JPY\n generic_symbol.. USDJPY\n base............ USD\n tenor........... Spot\n price_account .. 3CVi3EEprs1zeKhv5kw9EpRDv1hNfvpunQ98gex27Prd\nBest Practices\nThe users should not rely on the symbol name being unchanging or parse data out of the symbol.\nInstead, programs should always use the different attributes to identify the product you are interested in. You have to ensure that anything which is used to compose the symbol is made available as a stand-alone attribute.\nCaveats\nWe\u2019re limited to 464 bytes to store the attribute dictionary in v2 (the product account is 512 bytes and 48 are used for other fields). This has to hold all the keys and values, plus field separators. There is no data compression or abbreviation.\n\n\n\n\nPrice Aggregation\nPrice aggregation combines the prices and confidences submitted by individual data providers into a single aggregate price and confidence.\nDesign Goals\nThe aggregation algorithm is designed to achieve 3 properties. First, it must be robust to manipulation. If most publishers are submitting a price of $100 and one publisher submits a price of $80, the aggregate price should remain near $100 and not be overly influenced by the single outlying price. In the figure below, the aggregate price and confidence interval (represented by the red star) is not influenced by the blue publisher whose price is far away from the other publishers:\n  \n\nSecond, the aggregate price should appropriately weight data sources with different levels of accuracy. Pyth allows publishers to submit a confidence interval because they have varying levels of accuracy in observing the price of a product. This property can result in situations where one publisher reports a price of $101 +/- 1, and another reports $110 +/- 10. In these cases, we would like the aggregate price to be closer to $101 than $110, as in the figure below.\n  \n\nFinally, the aggregate confidence interval should reflect the variation between publishers\u2019 prices. Under normal market conditions, we expect the a product to trade at a similar price across exchanges. In these cases, we would like the aggregate confidence interval to reflect the confidence intervals of the individual data providers, as shown in the figure on the left. However, in some rare situations, a product can trade at different prices on different exchanges. In these cases, the aggregate confidence interval should widen out to reflect the variation between these prices, as shown in the figure on the right.\n  \n\nAlgorithm\nThe aggregation algorithm itself is a simple two-step process. The first step computes the aggregate price by giving each publisher three votes \u2014 one vote at their price and one vote at each of their price +/- their confidence interval \u2014 then taking the median of all the votes. The second step computes distance from the aggregate price to the 25th and 75th percentiles of the votes, then selects the larger of the two as the aggregate confidence interval.\nThis process acts like a hybrid between a mean and a median, giving confident publishers more influence, while still capping the maximum influence of any single publisher. The algorithm has an interpretation as computing the minimum of an objective function that penalizes the aggregate price from deviating too far from the publishers' prices. This interpretation allows us to prove properties of the algorithm's behavior: for example, the aggregate price will always lie between the 25th and 75th percentiles of the publishers' prices.\nScenarios\nWe can visualize the operation", "doc_id": "e98fca98-9ddb-4de8-87ad-c0ac568c230f", "embedding": null, "doc_hash": "9c68c346c8f5637aadd6d6608eef28c31a299424bcee97be63e1c5aa451e41a3", "extra_info": null, "node_info": {"start": 89992, "end": 93619}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "7b67bb4d-f238-431d-9e9e-0c1b933a5fe8", "3": "bbc38de6-46b1-4e33-8d86-59b4dad6b060"}}, "__type__": "1"}, "bbc38de6-46b1-4e33-8d86-59b4dad6b060": {"__data__": {"text": "to prove properties of the algorithm's behavior: for example, the aggregate price will always lie between the 25th and 75th percentiles of the publishers' prices.\nScenarios\nWe can visualize the operation of this algorithm and objective function in the 4 scenarios from above. In the following graphs, the colored bars represent each publisher's price and confidence interval, and the grey dashed lines above depict the publisher's contribution to the overall objective function. The red line represents the combined objective function, that is, the sum of the dashed grey lines. The grey circles represent the 25th and 75th percentiles of the votes \u2014 the further one of these from the aggregate price determines the confidence interval\u2019s width. Finally, the bold red star depicts the aggregate price and the bold red line depicts the aggregate confidence interval.\nIn the first scenario, one publisher with a tight confidence interval is an outlier. Although this publisher does influence the objective function (the red line is lower on the left side than the right), it does not have enough influence to affect either the aggregate price or confidence interval.\n  \n\nThe second scenario depicts how publishers with tighter confidence intervals can exert more influence over the location of the aggregate price, as long as their prices are consistent with the confidence intervals of other publishers.\n  \n\nThe third scenario demonstrates the typical case where there are many publishers whose prices and confidence intervals roughly agree. In this case, the desired behavior is for the aggregate price and confidence to reflect those of the individual publishers.\n  \n\nFinally, the fourth scenario considers the case where the publishers publish distinct prices with non-overlapping confidence intervals. In this case, the confidence interval widens out because the dispersion between publishers creates a large gap between the aggregate price and the 25th/75th percentiles of the votes.\n\n\n\n\nEMA Price Aggregation\nFor more details, please read out Medium Blog on the topic: https://pythnetwork.medium.com/whats-in-a-name-302a03e6c3e1\nPyth network also offers an exponentially-weighted moving average (EMA) price and confidence. These values are time-weighted averages of the aggregate price and confidence. Both the EMA price (ema_price) and confidence (ema_confidence) are available from Pyth price accounts:\nprice_account .. CqFJLrT4rSpA46RQkVYWn8tdBDuQ7p7RXcp6Um76oaph\n   price ........ 16297000 x 10^-5\n   conf ......... 27952 x 10^-5\n   price_type ... price\n   exponent ..... -5\n   status ....... trading\n   corp_act ..... nocorpact\n   num_qt ....... 2\n   valid_slot ... 110430111\n   publish_slot . 110430112\n   ema_price ......... 16247409 x 10^-5\n   ema_confidence ......... 19415 x 10^-5\nWhat is an exponential moving average (EMA)?\nIn an EMA the most recent samples receive the most weight, and samples further back in time get exponentially less weight the farther in the past they are. For a 1 hour EMA, the samples 1 hour in the past get 50% of the weighting, samples 2 hours in the past get 25% of the weighting, 3 hours in the past get 12.5% of the weighting, etc.\n  \n\nWhile conceptually not as simple as an SMA (Simple Moving Average), the EMA has a particularly simple implementation for streaming applications such as", "doc_id": "bbc38de6-46b1-4e33-8d86-59b4dad6b060", "embedding": null, "doc_hash": "815ca8baa8ba0c8959cd10c51a0f9f45887233c4140f6683255b70fae5a84d95", "extra_info": null, "node_info": {"start": 93511, "end": 96844}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "e98fca98-9ddb-4de8-87ad-c0ac568c230f", "3": "aa813a62-601b-4083-96bb-3c7093ae99b7"}}, "__type__": "1"}, "aa813a62-601b-4083-96bb-3c7093ae99b7": {"__data__": {"text": "in the past get 12.5% of the weighting, etc.\n  \n\nWhile conceptually not as simple as an SMA (Simple Moving Average), the EMA has a particularly simple implementation for streaming applications such as Pyth. The exponential weighting method allows the entire history of prices and weights to be represented by a single number.\nFind the implementation in our GitHub.\nHow does Pyth calculate its EMA PRICE and EMA Confidence?\nThe EMA Price (ema_price) and EMA Confidence (ema_confidence) values are derived directly from the aggregated prices and confidences Pyth has generated on-chain. Publishers do not submit either EMA Price or EMA Confidence values, they only publish to Solana a \u201clive\u201d price and its associated confidence interval which will, in turn, be used for EMA Price and EMA Confidence calculation.\nThe current Pyth averaging method is a slot-weighted, inverse confidence-weighted exponential moving average of the aggregate price (and confidence interval).\n      * Slot weighted \u2014 The Pyth EMA uses the Solana slot number to measure the passage of time. The averaging period is 5921 slots, which corresponds to approximately 1 hour on Solana mainnet.\n      * Inverse confidence weighted \u2014 Weighting each sample by 1/Confidence lets the EMA give more weight to samples with tight confidence and ignore samples with very wide confidence. Below is an example of an outlier aggregate price with a wide confidence interval. Notice how the average using inverse confidence weighting does not get pulled up by the outlier sample while the uniform weighted average does.\nSecurity\nThe Pyth software has undergone a number of audits from different firms. All of the audit reports are available in the audits github repository.\nPyth Network also offers a bug bounty program for reports of issues with the deployed code. Please visit the linked page for terms and conditions.\n\n\n\n\nWhitepaper\nFor more information, visit the Pyth whitepaper https://pyth.network/whitepaper\nGrowth in DeFi requires high-fidelity, time-sensitive, real-world data, direct from the source and made available on any L1 blockchain. Financial market data, however, is often accessible to only a limited set of institutions and users. Traditional markets typically maintain strict control over and access to both live and historical price feeds. Consequently, only a selected group of users has access to the most timely, accurate, and valuable information.\nThe Pyth network is a next-generation oracle solution that aims to bring this valuable financial market data to the general public. The network does so by incentivizing market participants \u2014 trading firms, market makers, and exchanges \u2014 to share directly on-chain the price data collected as part of their existing operations. Pyth's data providers include some of the largest traders, exchanges, and financial services players who create unique high quality market data. This includes real world market data in equities, fx, crypto, and metals with ambitions to scale across asset classes. Data publishers include Jump Trading Group, GTS, Jane Street, Hudson River Trading, LMAX, Virtu, BSX, CTC, and many more.\nThe network then aggregates this first-party price data (still on-chain) and makes it available for use by either on- or off-chain applications.\nEnd-users of Pyth data can elect to pay data fees to gain protection against a potential oracle failure. As data publishers must stake tokens in order to publish data for a product, the stake of at-fault publishers (if they make the aggregate price erroneous) will be used as a payout to", "doc_id": "aa813a62-601b-4083-96bb-3c7093ae99b7", "embedding": null, "doc_hash": "3c430f6c3b975ecd1bb41cdd81bb1ae533f29177e147c6666090a4a4f8e7a8ac", "extra_info": null, "node_info": {"start": 96852, "end": 100428}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "bbc38de6-46b1-4e33-8d86-59b4dad6b060", "3": "e29c0ba1-45c5-4563-b96e-5bf550470a35"}}, "__type__": "1"}, "e29c0ba1-45c5-4563-b96e-5bf550470a35": {"__data__": {"text": "publishers must stake tokens in order to publish data for a product, the stake of at-fault publishers (if they make the aggregate price erroneous) will be used as a payout to those end-users voluntarily paying fees. Delegators choose which product (price feed) and a publisher to stake on top of in order to earn data fees (or lose their stake if the oracle is inaccurate due to publisher faults). Initially, 80% of the data fees will go to delegators while the remaining 20% will be shared among publishers \u2014 this, among other parameters, will be subject to change through a PYTH governance.\nThe goal of the design and mechanics around the PYTH token aim to make the Pyth network self-sustaining and decentralized.\n\n\n\n\nNetwork Participants\nFor more information, visit the Pyth whitepaper https://pyth.network/whitepaper\n3 different types of stakeholders will interact within the network:\n      * Publishers publish price feeds and earn a share of data fees in exchange. Publishers are typically market participants with access to accurate, timely price information. The protocol rewards publishers in proportion to the quantity of new pricing information that they share.\n      * Consumers read price feeds, incorporate data into smart contracts or dApps, and optionally pay data fees. Consumers can either be on-chain protocols or off-chain applications.\n      * Delegators stake tokens on a specific product and publisher to earn a share of the data fees in exchange for potentially losing their stake if the oracle is inaccurate.\nAny actor may have multiple roles within the network. For instance, data publishers (or consumers) may additionally decide to delegate tokens to earn additional data fees.\n\n\n\n\nNetwork Interactions\nFor more information, visit the Pyth whitepaper https://pyth.network/whitepaper\nThe Pyth protocol consists of 4 on-chain core mechanisms:\n      * Price aggregation combines the reported prices and confidence intervals of individual publishers into a single price feed and confidence interval feed for a specific product (e.g. BTC/USD feed). This mechanism is designed to produce robust price feeds \u2014 feeds whose prices cannot be significantly influenced by small groups of publishers.\n      * Data staking allows delegators to stake tokens to earn data fees. The delegators in aggregate also determine the level of influence (stake-weight) that each publisher has on the aggregate price. In addition, this mechanism determines whether delegators\u2019 stakes are slashed. Finally, the mechanism collects data fees from consumers and distributes a share to delegators (initially set at 80%). The remainder (20%) goes into a reward pool that is distributed among publishers.\n      * Reward distribution determines the share of the reward pool earned by each publisher. Each product has a reward pool that delegators can stake into. The reward distribution mechanism preferentially rewards publishers with higher quality price feeds and reduces the likelihood that uninformed publishers will earn rewards.\n      * Governance will be using a coin-voting system that will help determine the high-level parameters of the three mechanisms above. Parameters include what types of tokens may be used for data fees; which products are listed on Pyth; the share of", "doc_id": "e29c0ba1-45c5-4563-b96e-5bf550470a35", "embedding": null, "doc_hash": "0bd242d037de44eece742f1f162441f84cb206b1a6a7e1c4932bba762f020e8e", "extra_info": null, "node_info": {"start": 100453, "end": 103732}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "aa813a62-601b-4083-96bb-3c7093ae99b7", "3": "ca02e6c2-04fb-42bb-8f0b-8d7b5a00160d"}}, "__type__": "1"}, "ca02e6c2-04fb-42bb-8f0b-8d7b5a00160d": {"__data__": {"text": "system that will help determine the high-level parameters of the three mechanisms above. Parameters include what types of tokens may be used for data fees; which products are listed on Pyth; the share of data fees allocated to publishers, delegators, and other uses; the number of PYTH tokens that publishers must stake or enable claims to be filed against a product, and more.\n\n\n\n\nParticipant Incentives\nFor more information, visit the Pyth whitepaper https://pyth.network/whitepaper\nThis section summarizes the benefits for the various Pyth network stakeholders:\nPublishers are incentivized to stake PYTH tokens to participate in the protocol and earn a share of the rewards. Publishers earn a share of the data fees for the products they price. The data fees for a product will likely grow in proportion to consumer usage of the price feed. Publishing erroneous data (voluntarily or not) to the network may lead to the publisher's stake being slashed.\nConsumers are incentivized to pay data fees because paying data fees attracts more publishers to the product, which improves the robustness of the price feed.\nDelegators are incentivized to participate in the protocol to earn data fees (coming from consumers\u2019 data fees). Delegators will initially earn attractive payments, but competition between them will reduce the payments over time as the market becomes more efficient.", "doc_id": "ca02e6c2-04fb-42bb-8f0b-8d7b5a00160d", "embedding": null, "doc_hash": "0b6db9242151633cdb59aee89b69349a96d03b940561b714dcfd39a9ffb07ca7", "extra_info": null, "node_info": {"start": 103673, "end": 105053}, "relationships": {"1": "733edcd7-b46c-431b-b60f-281d6da85dc6", "2": "e29c0ba1-45c5-4563-b96e-5bf550470a35"}}, "__type__": "1"}, "013ffed8-91d4-419c-9b63-3cdd0addc827": {"__data__": {"text": "Answers for Quiz IV:\n\n1. So what is Pyth anyways?\n\n1) a specialized oracle solution for latencysensitive financial data that is typically kept behind the \u201cwalled gardens\u201d of centralized institutions.\n\n2) a solution which brings valuable financial market data to DeFi applications and the general public.\n\n3) a data aggregation platform for DeFi supported by some of the best global financial players who are providing their own proprietary data.\n\nhttps://pythnetwork.medium.com/todaywerebeyondexcitedtointroducethepythnetworkanextgenerationoraclesolution735a27504358\n\nPyth does not collect data from third party sources (aggregators, public internet resources).\n\nhttps://pythnetwork.medium.com/publishervsreporternetworkse6b11f79abb0\n\n\n2. Why is Pyth on Solana?\n\nSolana allows Pyth to continuously stream such data at a subsecond latency and at affordable costs.\n\nhttps://pythnetwork.medium.com/pythnetworkwantstogofast26596a7c1f97\n\n\n3. What is special about Pyth\u2019s data quality?\n\nPyth\u2019s publishers are all firstparty providers, meaning they own and create the data they send to Pyth). Data is not taken from opaque or questionable sources.\n\nPyth\u2019s data is sent directly from an original source to the blockchain, as opposed to being aggregated from a third party or collected from the public internet.\n\nThe entire data publishing and aggregation process on the Pyth network is transparent, onchain and verifiable.\n\nhttps://pythnetwork.medium.com/publishervsreporternetworkse6b11f79abb0\n\n\n4. What are the different roles on the Pyth network?\n\nPublisher\nDelegator\nConsumer\n\n5. Who can use Pyth\u2019s data?\n\nPyth\u2019s data is free and continuously streaming: anyone can use it, and Consumers will be able to pay data fees to hedge against oracle risk (receive a payout if price feeds do not perform as expected).\n\n\nMedium Questions\n\n6. What are Pyth\u2019s Confidence Intervals? What do \u201cwider\u201d or \u201clarger\u201d Confidence Intervals mean?\n\nConfidence Intervals are reflections of publishers\u2019 measurement uncertainties of their own published prices. The Confidence Interval band around a price illustrates where the price is most likely to be. Wider Intervals mean more uncertainty for the price at that point in time.\n\nThis is a unique feature to the Pyth network. Reporter Networks would have extreme difficulty replicating this kind of feature.\n\nhttps://pythnetwork.medium.com/whatisconfidenceuncertaintyinaprice649583b598cf\n\nSee also: https://pythnetwork.medium.com/pythiad1thejourneysofarc4c951271805 (\u201dGot Confidence\u201d section)\n\n\n7. Why does Pyth aggregate its publisher\u2019s price quotes?\n\nAggregation allows Pyth to:\n\n1) remove and resist outlier prices such that the final price output (for a product supported by multiple publishers) is accurate.\n\n2) generate an \u2018aggregate Confidence Interval\u2019 to determine the price uncertainty for the final price output.\n\n3) Pyth to generate a final price output which cannot be significantly influenced by a small group of publishers.\n\nhttps://docs.pyth.network/howpythworks/priceaggregation\n\nSee also: https://pythnetwork.medium.com/pythpriceaggregationproposal770bfb686641\n\nFurther reading: https://pyth.network/whitepaper\n\n\n8. Which of the following is true (in terms of the Pyth whitepaper)?\n\nPublishers publish price and confidence intervals and earn a share of data fees in exchange.\n\nConsumers read price feeds, incorporate data into smart contracts or dApps, and optionally pay data fees.\n\nDelegators stake tokens and earn data fees in exchange for potentially losing their stake if the oracle is", "doc_id": "013ffed8-91d4-419c-9b63-3cdd0addc827", "embedding": null, "doc_hash": "b77dc17b77af144d06ee27679961515f4f0b9bb23c2e27bfc94f7188b0e832f4", "extra_info": null, "node_info": {"start": 0, "end": 3528}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "3": "23324207-911e-477a-b361-8f3bc2f676dd"}}, "__type__": "1"}, "23324207-911e-477a-b361-8f3bc2f676dd": {"__data__": {"text": "Pyth to generate a final price output which cannot be significantly influenced by a small group of publishers.\n\nhttps://docs.pyth.network/howpythworks/priceaggregation\n\nSee also: https://pythnetwork.medium.com/pythpriceaggregationproposal770bfb686641\n\nFurther reading: https://pyth.network/whitepaper\n\n\n8. Which of the following is true (in terms of the Pyth whitepaper)?\n\nPublishers publish price and confidence intervals and earn a share of data fees in exchange.\n\nConsumers read price feeds, incorporate data into smart contracts or dApps, and optionally pay data fees.\n\nDelegators stake tokens and earn data fees in exchange for potentially losing their stake if the oracle is inaccurate.\n\nPrice aggregation combines the price feeds of individual publishers into a single price feed for the product.\n\nConsumers do not stake insofar that they are Consumers. Of course, one can hold multiple roles in the network. A Consumer could likewise choose to be a Delegator, technically speaking.\n\nGovernance determines many parameters of the Pyth network, but qualitative features like the literal name of \u201cPyth network\u201d do not fall under governance\u2019s domain...\n\nFurther reading: https://pyth.network/whitepaper\n\n\n\n9. Parts of the Pyth protocol will run in epochs. What is an epoch?\n\nA number of Solana slots corresponding to approximately one week of realtime.\n\nSee: https://pyth.network/whitepaper\n\nSee also: https://docs.solana.com/terminology\n\n\n\nHard Questions\n\n10. Where does the name Pyth come from anyways?\n\nPyth is a reference to Pythia, the high priestess of the Temple of Apollo.\n\nThe Note appended to Question 10 was deliberately misleading. We do not apologize.\n\n\n\n11. How long do the data fees paid by consumers cover for an oracle failure?\n\n4 epoch after the fees have been paid.\n\nSee: https://pyth.network/whitepaper\n\n\n\n12. Why is requesting to unstake instantaneous, but the receipt of your unstaked tokens delayed?\n\nThis staking design guarantees that the quantity of PYTH tokens staked toward any given activity remains constant within an epoch.\n\nSee: https://pyth.network/whitepaper\n\n\n13. What is true about the Pyth network\u2019s HUMAN task process?\n\nThe HUMAN task is essentially an approach towards providing a trustless benchmark between onchain results and offchain truth for disputes over the oracle\u2019s results.\n\nA Claim includes the product for which incorrect data appeared, the time interval when that incorrect data appeared, and the results of a HUMAN protocol task to determine the truth of the claim and which publishers were at fault.\n\nHUMAN task will ask a random sample of workers to report several pieces of offchain information, including the maximum and minimum price for the product during the time interval (in question) on a fixed set of reference exchanges.\n\nNote: The HUMAN task will involve opensource software...*\n\nSee: https://pyth.network/whitepaper\n\n\n\n14. The order book (as a trade execution model) gives rise to what is known as the bidask spread. Exchange ABC is a publisher for Pyth for Feed X/Y. How does the bidask spread inform the aggregate output for X/Y?\n\nA correct answer would say something like:\n\n\u201cA data provider focused on a particular market could represent confidence as the bid / ask spread on that venue.\u201d\n\nSee: https://pythnetwork.medium.com/whatisconfidenceuncertaintyinaprice649583b598cf\nConfer with: https://pythnetwork.medium.com/pythiad2liberatingfirstpartydataa7ccb865ed62 (\u201dNew Publishers!\u201d section)\n\n\n\n15. Financial market data can be defined as a combination of the following:\n\nTrade orders defining the prices traders with to trade", "doc_id": "23324207-911e-477a-b361-8f3bc2f676dd", "embedding": null, "doc_hash": "749ffe0ff0edd3ba4a2757cbb80a783384ded1b1b3e78be3ab30b8e0aac415e9", "extra_info": null, "node_info": {"start": 2928, "end": 6526}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "013ffed8-91d4-419c-9b63-3cdd0addc827", "3": "5d8183f4-642d-45f2-8854-9f06d3bac85a"}}, "__type__": "1"}, "5d8183f4-642d-45f2-8854-9f06d3bac85a": {"__data__": {"text": "(as a trade execution model) gives rise to what is known as the bidask spread. Exchange ABC is a publisher for Pyth for Feed X/Y. How does the bidask spread inform the aggregate output for X/Y?\n\nA correct answer would say something like:\n\n\u201cA data provider focused on a particular market could represent confidence as the bid / ask spread on that venue.\u201d\n\nSee: https://pythnetwork.medium.com/whatisconfidenceuncertaintyinaprice649583b598cf\nConfer with: https://pythnetwork.medium.com/pythiad2liberatingfirstpartydataa7ccb865ed62 (\u201dNew Publishers!\u201d section)\n\n\n\n15. Financial market data can be defined as a combination of the following:\n\nTrade orders defining the prices traders with to trade at.\n\nPrices at which trades have just occurred in general.\n\nSee: https://pythnetwork.medium.com/pythandfinancialmarketdata978aac337e8\n\n\n\nLegendary Questions\n\nCongratulations on making it this far, by the way. You have proven your valiance. Very well done!\n\n16. How often (at what frequency) will Delegators earn their rewards? (Assuming no claim has been raised and ratified).\n\nNote: This is not to be mistaken for Publisher rewards!\n\nThis can be inferred.\n\nThe data staking mechanism allows Delegators to stake tokens to earn fees. (Whitepaper p.3)\n\nThe data staking mechanism collects data fees from Consumers and distributes a share to Delegators. (p.3)\n\nThe remainder goes into a reward pool that is distributed to Publishers. (p.3)\n\nThe Rewards mechanism will distribute rewards to Publishers at the end of each epoch. (p.9).\n\nInsofar as Publishers are rewarded, a splitting of a reward pool must have happened such that Delegators have been rewarded too. Furthermore, we know that the protocol runs strictly in per epoch periods, so Delegators should not be receiving rewards at different times than Publishers qua staker.\n\n\n\n17. Suppose there are 5 data providers publishing for a feed. Assuming all else is equal, how much will each publisher earn in rewards from the data fees pool (for that feed), percentagewise?\n\nOne reward pool exists for that product.\n\n20% of the pool would be distributed among Publishers.\n\nSince there are 5 Publishers, each one would receive up to 4% of the original pool.\n\n\n18. Let\u2019s say a borrowlending app (Consumer) uses the Pyth confidence interval as well as the price quote from Feed P/Q. (Good for them!). At time t(0), the price of P is 1000Q plusminus 50Q.\n\nConsumer computes a range in which the true price (probably) lies, using a multiple of 1.\n\nUsers on Consumer are borrowing Q. What is the LEAST conservative price (P) which Consumer can impose on its borrowers for liquidation purposes? (Conservative meaning the Consumer is avoiding liquidating users).\n\nAdmittedly, this question is a bit unfair and esoterically worded.\n\nConsumer is lending Q to its users. P is priced in Q. For example, for the SOL/USD feed, SOL is priced in USD.\n\nIn our question, the Consumer is choosing the least conservative price P, meaning they are preferring to liquidate its users as opposed to not liquidating.\n\nYes, there is a true price Q for any 1 unit of P. However, the Confidence Interval reflects measurement uncertainty across all publishers backing product (price feed) P/Q. Hence, Pyth is putting out an aggregate Price P in terms of Q, plus a Confidence Interval. So the price of 1 P is xQ plus minus some Confidence Interval.\n\nThe Consumer is trying to liquidating its users: this implies that the users, who are borrowing (short) Q should hopefully not hit their margin thresholds. Q should not be too \u201cexpensive\u201d.\n\nBut wait, what is the collateral for Q? Is it Q or P?\n\nIf it were Q, then none of the answers would", "doc_id": "5d8183f4-642d-45f2-8854-9f06d3bac85a", "embedding": null, "doc_hash": "99b45b9d02ec751ee4aa72270f9797b059b3d6ac63998ad3a53b2509c8247b5f", "extra_info": null, "node_info": {"start": 6524, "end": 10174}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "23324207-911e-477a-b361-8f3bc2f676dd", "3": "e8ac8239-ba47-4459-88ca-f706b730d2ed"}}, "__type__": "1"}, "e8ac8239-ba47-4459-88ca-f706b730d2ed": {"__data__": {"text": "conservative price P, meaning they are preferring to liquidate its users as opposed to not liquidating.\n\nYes, there is a true price Q for any 1 unit of P. However, the Confidence Interval reflects measurement uncertainty across all publishers backing product (price feed) P/Q. Hence, Pyth is putting out an aggregate Price P in terms of Q, plus a Confidence Interval. So the price of 1 P is xQ plus minus some Confidence Interval.\n\nThe Consumer is trying to liquidating its users: this implies that the users, who are borrowing (short) Q should hopefully not hit their margin thresholds. Q should not be too \u201cexpensive\u201d.\n\nBut wait, what is the collateral for Q? Is it Q or P?\n\nIf it were Q, then none of the answers would technically be relevant. (I.e. forex is just purchasing parity).\n\nWe can infer, then, that P is the collateral for the users\u2019 borrowing Q. If Consumer is trying hard to liquidate its users, then they will want to say that the value of P at t(0) is \u2018too cheap\u2019. How \u2018cheap\u2019? According to the Confidence Interval, whereby Consumer is computing a range using a multiple of 1, the (lowest) Price of P is 1000Q minus 50Q. P is worth 950Q, says the Consumer. Users deemed to not have enough P as collateral may get liquidated.\n\n\n19. How frequently has a new publisher joined the Pyth network since Pyth was first publicly announced?\n\nPyth\u2019s hello world moment was April 7, 2021.\n\nQuiz IV was published on April 4, 2022. That\u2019s approximately 51.71 weeks.\n\nAs of April 4, 2022, Pyth had announced 53 publishers. That\u2019s a little more than 1 publisher per week or epoch.\n\n\n20. Pyth has many stakeholders and network supporters. Can you identify them in the list below?\n\nThe correct answer is that every single name in the list is a stakeholder or supporter of the Pyth network. The full list, plus some interesting comments and links for special cases:\n\n01 Protocol: Consumer\n\nAlameda Research: Publisher\n\nAmber Group: Publisher\n\nApricot: Consumer\n\nBonfida: Consumer\n\nCoinShares: Publisher\n\nCypher: Consumer\n\nCrux: Consumer. This is interesting. Crux serves data to its own crypto data users. So Crux serves Pyth data to these users!\nhttps://twitter.com/PythNetwork/status/1506641837267824647\n\nDFlow: Consumer\n\nFTX: Publisher\n\nGate.io: Publisher\n\nHubble: Consumer\n\nHXRO: Consumer\n\nIdeal Prediction: Consumer. Firstever crypto analytics API using Pyth network market data!\nhttps://twitter.com/PythNetwork/status/1488844545081200646\n\nIEX Cloud: Publisher\n\nJane Street: Publisher\n\nJet Protocol: Consumer\n\nJump Trading: Publisher\n\nKatana: Consumer\n\nMango Markets: Consumer\n\nNeon EVM: Integrationsrelated partner.\nhttps://www.businesswire.com/news/home/20211229005282/en/NeonLabsIntegrateswiththePythNetworktoUnlockHiFiPriceFeedsforDevelopers\n\nPort Finance: Consumer\n\nPsyOptions: Consumer\n\nRaydium: Publisher\n\nRibbon Finance: Consumer. Ribbon automatically settles vaults on Solana using Pyth\u2019s price feeds and Zeta FLEX.\nhttps://twitter.com/PythNetwork/status/1499702605064384517\n\nSerum: Publisher\n\nSolend: Consumer\n\nSolrise Finance: Consumer\n\nSynthetify: Consumer\n\nThree Arrows Capital: Publisher\n\nUXD: Consumer\n\nWintermute: Publisher\n\nZeta Markets: Consumer\n\n0x Labs: Publisher\n\nAnswers for Quiz X (#10).\n\nEasy:\n\n1. What is Pyth network?\n\nPyth network sends data from the realworld to the blockchain.\n\nPyth network unlocks latencysensitive financial data that is typically kept behind the \u201cwalled gardens\u201d of centralized", "doc_id": "e8ac8239-ba47-4459-88ca-f706b730d2ed", "embedding": null, "doc_hash": "55dfc5134b400000c196d7552482e195f0d810fca13d1a1cbafff7a17bc07353", "extra_info": null, "node_info": {"start": 10181, "end": 13611}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "5d8183f4-642d-45f2-8854-9f06d3bac85a", "3": "060803e8-91f4-4541-a7e8-60250a4c70a4"}}, "__type__": "1"}, "060803e8-91f4-4541-a7e8-60250a4c70a4": {"__data__": {"text": "Publisher\n\nRibbon Finance: Consumer. Ribbon automatically settles vaults on Solana using Pyth\u2019s price feeds and Zeta FLEX.\nhttps://twitter.com/PythNetwork/status/1499702605064384517\n\nSerum: Publisher\n\nSolend: Consumer\n\nSolrise Finance: Consumer\n\nSynthetify: Consumer\n\nThree Arrows Capital: Publisher\n\nUXD: Consumer\n\nWintermute: Publisher\n\nZeta Markets: Consumer\n\n0x Labs: Publisher\n\nAnswers for Quiz X (#10).\n\nEasy:\n\n1. What is Pyth network?\n\nPyth network sends data from the realworld to the blockchain.\n\nPyth network unlocks latencysensitive financial data that is typically kept behind the \u201cwalled gardens\u201d of centralized institutions.\n\nPyth network is a data aggregation platform where some of the best global financial players provide their proprietary data to the world.\n\n2. What is special about Pyth\u2019s publishers (data sources)?\n\nPyth\u2019s publishers are major financial players who are owners of valuable data and who possess strong market expertise.\n\nPyth\u2019s publishers are creators and owners of unique financial data. (They do not usually sell this data as part of their daily operations).\n\n3. What are the different roles on the Pyth network?\n\nPublishers  provide data to Pyth to earn rewards\n\nConsumers  use Pyth\u2019s data securely\n\nDelegators  support Pyth network to earn rewards\n\n4. What are the upcoming utilities of the $PYTH token? (Note, the $PYTH token is currently not listed. Please be cautious of fraudsters.)\n\nConsumers can consume Pyth data for their applications and (optionally) pay data fees in $PYTH for protection against oracle risk.\n\nPublishers must stake $PYTH in order to submit data to the Pyth network and earn a share of data fees for their work.\n\nPublishers will have their ($PYTH) stakes slashed if they submit bad data (delayed, inaccurate, or obviously copied) data to the Pyth network.\n\nDelegators can stake $PYTH to help secure the network\u2019s price feeds, encourage more publishers and consumers to participate, and earn rewards for doing so.\n\nAnyone can use $PYTH to vote in Pyth network\u2019s coinstaking governance system.\n\nMedium:\n\n5. Who uses Pyth data?\n\nSee https://pyth.network/consumers. Note that other oracles, at least to our knowledge, do not use Pyth data\u2026\n\nRibbon Finance\n\nMango Markets\n\nSolend\n\n01 Exchange\n\nKatana\n\nFriktion\n\nBonfida\n\nPort Finance\n\nZeta Markets\n\nSynthetify\n\nHubble\n\nHedge\n\n6. What are the requirements for using Pyth data?\n\nSee also: https://github.com/pythnetwork\n\nAny participant can use Pyth\u2019s data for free.\n\n7. What is a confidence interval in Pyth network? Why is it important?\n\nThe confidence interval is a \u201cband\u201d around a price which shows where the price is most likely to be. Wider bands means more uncertainty in that price during that point in time. This metric allows Consumers to make smarter decisions with Pyth\u2019s data.\n\nhttps://pythnetwork.medium.com/649583b598cf\nMedium\nWhat is Confidence/Uncertainty in a Price?\nPyth data providers stream a price along with the confidence/uncertainty that they estimate using information available to them.\nWhat is Confidence/Uncertainty in a Price?\nHard:\n\n8. What are the benefits of Pyth aggregating multiple publishers for a single price feed?\n\nAggregation allows Pyth to eliminate outlier price inputs so that the final output is accurate.\n\nAggregation allows Pyth to generate an aggregate price, aggregate confidence interval, aggregate EMA (exponential moving average), and EMAC (exponential moving average confidence).\n\nPyth\u2019s aggregation is done completely", "doc_id": "060803e8-91f4-4541-a7e8-60250a4c70a4", "embedding": null, "doc_hash": "dd5c246c1c314fc23947ae15d8c28f9ee0ebe2939b255aaada7df689b97821a5", "extra_info": null, "node_info": {"start": 13647, "end": 17128}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "e8ac8239-ba47-4459-88ca-f706b730d2ed", "3": "e36fbe1c-9094-4b53-9bff-b5163ddbc739"}}, "__type__": "1"}, "e36fbe1c-9094-4b53-9bff-b5163ddbc739": {"__data__": {"text": "in time. This metric allows Consumers to make smarter decisions with Pyth\u2019s data.\n\nhttps://pythnetwork.medium.com/649583b598cf\nMedium\nWhat is Confidence/Uncertainty in a Price?\nPyth data providers stream a price along with the confidence/uncertainty that they estimate using information available to them.\nWhat is Confidence/Uncertainty in a Price?\nHard:\n\n8. What are the benefits of Pyth aggregating multiple publishers for a single price feed?\n\nAggregation allows Pyth to eliminate outlier price inputs so that the final output is accurate.\n\nAggregation allows Pyth to generate an aggregate price, aggregate confidence interval, aggregate EMA (exponential moving average), and EMAC (exponential moving average confidence).\n\nPyth\u2019s aggregation is done completely onchain. This is a unique characteristic of Pyth that makes Pyth\u2019s data more transparent, secure, and safe.\n\n9. Where does the name Pyth come from anyways?\n\nNote: https://github.com/pythnetwork/pythclientpy\n\nNone of the above.\n\nPyth is a reference to Pythia, the high priestess and oracle of Delphi.\nGitHub\nGitHub  pythnetwork/pythclientpy: Python client for pyth oncha...\nPython client for pyth onchain data. Contribute to pythnetwork/pythclientpy development by creating an account on GitHub.\nGitHub  pythnetwork/pythclientpy: Python client for pyth oncha...\nLegendary:\n\n10. Extra Credit Essay: What makes Pyth unique from other oracles?\n\nPossible answers:\n\nSourcing: Pyth uses only firstparty providers. Pyth\u2019s publishers own their data, so there are no data restriction issues for Pyth downstream. Pyth does not scrape from public internet sources. The data sources on the Pyth network can therefore be held liable for their data\u2019s quality!\n\nMore on sourcing: Pyth\u2019s data sources are worldclass market participants. The level of data quality (fidelity, accuracy) is unparalleled. See Pyth\u2019s performance during the LUNA event and how Pyth could quote at even the smallest ticks.\n\nTransparency and Security: Pyth\u2019s publishers must send price and confidence quotes to Pyth\u2019s fully onchain program. There are no offchain components in the aggregation. Everyone in the world can see the same inputs and receives the same output at the same time. Information symmetry is maximized. The known vectors of attack for MEV are not present in Pyth network.\n\nHistorical: Pyth is a historic first where market participants who are cutthroat and would never be in the same room are now collaborating together, and on a DeFi project of all things!\n\nBusiness Model: Pyth\u2019s business model is unique. Data is free and future Consumers will be able to pay data fees to become eligible for payout in case of oracle failure. This is a model that accommodates everyone, from people running simple dashboards to people serving millions of users and who must protect those users and funds.\n\nThe answers to Quiz #12, Pyth's Next Steps\n\n1/ What is the Pyth network's mission?\n\nTo make every asset type available on every chain, and empower data owners and data users.\n\nSimple as that!\n\nYou can\u2019t \u201ctrade\u201d on the Pyth platform (we\u2019re not a DEX) and we don\u2019t collect data from unknown or hidden sources.\n\n2/ Who are Pyth data providers?\n\nEvery household name in that list is a Pyth data provider.\n\nYes, FTX and Huobi.\n\nYes, CBOE and Jane Street.\n\nYes, MEXC and Gemini and AAX and everyone else.\n\n3/ Who is using Pyth data?\n\nYes, all these names from Solana, Ethereum, and BNB Chain are using Pyth data: names like Venus, Ribbon, Solend, Zeta, and many more!\n\n4/ Why do developers like building on Pyth?\n\nDon\u2019t assume Pyth is just about big publishers! 90% of Solana DeFi uses", "doc_id": "e36fbe1c-9094-4b53-9bff-b5163ddbc739", "embedding": null, "doc_hash": "ed4b12d976d3a1a13c6c28a5fc5d7e227d95d7eaf5332e51fc2e37a5b294df96", "extra_info": null, "node_info": {"start": 17021, "end": 20634}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "060803e8-91f4-4541-a7e8-60250a4c70a4", "3": "afee92ad-e024-41b6-8cd3-3e0ffed148ae"}}, "__type__": "1"}, "afee92ad-e024-41b6-8cd3-3e0ffed148ae": {"__data__": {"text": "\u201ctrade\u201d on the Pyth platform (we\u2019re not a DEX) and we don\u2019t collect data from unknown or hidden sources.\n\n2/ Who are Pyth data providers?\n\nEvery household name in that list is a Pyth data provider.\n\nYes, FTX and Huobi.\n\nYes, CBOE and Jane Street.\n\nYes, MEXC and Gemini and AAX and everyone else.\n\n3/ Who is using Pyth data?\n\nYes, all these names from Solana, Ethereum, and BNB Chain are using Pyth data: names like Venus, Ribbon, Solend, Zeta, and many more!\n\n4/ Why do developers like building on Pyth?\n\nDon\u2019t assume Pyth is just about big publishers! 90% of Solana DeFi uses Pyth. Pyth data is extending now into BNB Chain, Aptos, and other EVM chains with launch partners lined up!\n\nWhy?\n\nPyth the fastest oracle.\n\nPyth is the only oracle that protects you with Confidence Intervals.\n\nPyth sources from firstparty sources \u2014 data owners who truly know asset prices. No gimmicks, no playing a long game of telephone, no nonsense.\n\n\n5/ How does Wormhole help Pyth go crosschain?\n\nWormhole allows Pyth to relay price updates from the Pyth program to all the Wormholesupported chains.\n\n6/ How many Pyth price feeds will be live on BNB Chain?\n\nAll of them.\n\nThis scalability applies to every single Wormhole chain.\n\nThink about that.\n\n7/ Which BNB Chain feeds does Pyth currently support?\n\nhttps://pyth.network/pricefeeds is a great place to get some\u2026alpha\u2026\n\n8/ Which chain(s) will Pyth expand to after BNB Chain?\n\nHeh. All of them.\n\n\n1112/ What are the planned utility functions of the PYTH token? What will Delegators do?\n\nReaders of the whitepaper benefit here. There\u2019s a lot of planned utility. Governance is key to this! We can\u2019t emphasize this enough. The network is becoming your network too.\n\n13/ Why are so many institutions and people choosing to get involved in the Pyth network?\n\nIt can be easy to lose track of the big picture!\n\nProblem:\n\nThe data and oracle solutions before Pyth were incomplete and cannot smoothly scale to support multiple asset prices at high quality and speeds.\n\nPyth came up with an answer. The publishers understand what Pyth is trying to do. They understand that the oracle problem is fundamental to the growth of Web3. If you\u2019re betting on Web3 and DeFi in to grow, you need to first solve the oracle problem.\n\nThe cool thing? Pyth empowers builders AND data owners.\n\nPyth, like Airbnb with spare rooms and vacation homes, unlocks new highquality sources of data supply. People who own valuable data can now contribute that data and earn rewards!\n\n1. Who was the Pythia?\n\nPythia refers to a priestess who communed with the gods. https://medium.com/@pythnetwork/whatsinanamepythandthepythiaac1bc08c3d3c\n\n2. What is the Pyth Network?\n\nWe deliver data. We're a blockchain oracle focusing on financial data. We're not a trading platform!\n\n3. What's the relationship between Pythia and the Pyth Network?\n\nPyth is a reference to Pythia, Oracle of Delphi. Pyth is therefore the Oracle of DeFi.  It would be wild if the Discord admins were getting it wrong since April 2021 :sad:\n\n4. Where is Pyth data available?\n\nEthereum\nOptimism\nArbitrum\nSolana\nAurora\nAptos\nCelo\nAnd way more. See pyth.network for some teasers...\n\n5. Who is using Pyth data?\n\nWho isn't??\n\nSynthetix, Kwenta, CAP Finance, Ribbon, Aurigami, Solend,", "doc_id": "afee92ad-e024-41b6-8cd3-3e0ffed148ae", "embedding": null, "doc_hash": "ab61d1fcab7a3c716384e56623b233d65dd57a428de1b2a688f22cd26d928e32", "extra_info": null, "node_info": {"start": 20824, "end": 24069}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "e36fbe1c-9094-4b53-9bff-b5163ddbc739", "3": "41002785-c66f-41d4-aa4c-417da94dc5ae"}}, "__type__": "1"}, "41002785-c66f-41d4-aa4c-417da94dc5ae": {"__data__": {"text": "the Pyth Network?\n\nWe deliver data. We're a blockchain oracle focusing on financial data. We're not a trading platform!\n\n3. What's the relationship between Pythia and the Pyth Network?\n\nPyth is a reference to Pythia, Oracle of Delphi. Pyth is therefore the Oracle of DeFi.  It would be wild if the Discord admins were getting it wrong since April 2021 :sad:\n\n4. Where is Pyth data available?\n\nEthereum\nOptimism\nArbitrum\nSolana\nAurora\nAptos\nCelo\nAnd way more. See pyth.network for some teasers...\n\n5. Who is using Pyth data?\n\nWho isn't??\n\nSynthetix, Kwenta, CAP Finance, Ribbon, Aurigami, Solend, Tullip...\n\n6. Pyth data comes from market makers, exchanges, and trading firms. Why?\n\nWe accidentally made this into a trick question. There's multiple answers that are right here:\n\nThese players are firstparty data sources: they create and own the data they give to Pyth. This means greater transparency, security, and assurance of data quality!\n\nThese market participants also actively participate in price discovery. They truly know the prices of different assets!\n\nBy attracting these kinds of market players to the network, Pyth gets access to data that you would otherwise have to pay a lot of money to obtain: think of Bloomberg terminal and exchange API subscriptions! (More than $30K a year!)\n\n7. What is unique about Pyth data?\n\nA lot!\n\nPythnet prices update every 400ms. Apps on other chains pull in that data whenever they need it  no wasted gas!\n\nPyth offers UNIQUE data for FREE: Live US equities, live FX (even outside normal trading hours!), metals and more!\n\nNo middlemen. All Pyth feeds available on all chains. Scalable.\n\n\n8. Where is Pyth generating fees? (Ignore Solana for now)\n\nThe Pyth protocol collects a small \"update fee\" for each update request from apps on other blockchains. See https://docs.pyth.network/ for more information.\n\nWe will find the people who answered \"cookie sales\" and transform them into cookies to be eaten.\n\n9. Why are major household names joining the Pyth Network?\n\nThese data providers are betting on Web3 and DeFi to grow. They know that the solutions before Pyth were incomplete and unlikely to scale to support multiple asset classes at high fidelity.\n\nPyth, like Airbnb with spare rooms and vacation homes, unlocks new highquality sources of data supply by giving these market players an incentive to make their data public.\n\nPyth's pull oracle model is gas efficient, updates at high frequencies, delivers data at low latencies, offers a wide range of price feeds and safety features like Confidence Intervals, and is reliable under volatile conditions thanks to Pythnet.\n\nPyth data powers 100 applications for 12+ blockchains. Pyth prices update >200,000 a day. Pyth has supported more than $35 billion in total trading volume. The Pyth client has been downloaded over 650K times. Pyth is a hidden gem. Our hidden gem.\n\nWhat does the Pyth network do?\n\n\nDelivers lowlatency prices to multiple blockchains\n\nAggregates data from multiple data sources for publishing to DeFi apps\n\nOffers 200+ price feeds across crypto, equities, commodities, and FX\n\n...\n\nWhat is the relationship between Pyth and Wormhole?\n\n\nWormhole allows Pyth price data to reach multiple blockchains\n\n...\n\nSelect the correct flow of data in the Pyth network\n\n\nData Providers  Pyth Program (Aggregation)  Wormhole  Blockchains\n\n...\n\nWhich of the following is true about Pyth price feeds?\n\n\nPyth price feeds update at high frequency, faster than most block times.\n\nPyth price feeds are lowlatency, users always get the freshest price.\n\nThere are 200+ price feeds available on every Pythsupported chain.\n\nOnce Pyth releases a new price feed, it", "doc_id": "41002785-c66f-41d4-aa4c-417da94dc5ae", "embedding": null, "doc_hash": "ec590efc1c5f11b8ec5331d459a5b233f6f021c1f923cc0e5034817c5b37c5a4", "extra_info": null, "node_info": {"start": 24039, "end": 27702}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "afee92ad-e024-41b6-8cd3-3e0ffed148ae", "3": "8f9bddbd-80ff-4173-a15a-2bdefb33422e"}}, "__type__": "1"}, "8f9bddbd-80ff-4173-a15a-2bdefb33422e": {"__data__": {"text": "data from multiple data sources for publishing to DeFi apps\n\nOffers 200+ price feeds across crypto, equities, commodities, and FX\n\n...\n\nWhat is the relationship between Pyth and Wormhole?\n\n\nWormhole allows Pyth price data to reach multiple blockchains\n\n...\n\nSelect the correct flow of data in the Pyth network\n\n\nData Providers  Pyth Program (Aggregation)  Wormhole  Blockchains\n\n...\n\nWhich of the following is true about Pyth price feeds?\n\n\nPyth price feeds update at high frequency, faster than most block times.\n\nPyth price feeds are lowlatency, users always get the freshest price.\n\nThere are 200+ price feeds available on every Pythsupported chain.\n\nOnce Pyth releases a new price feed, it becomes available on every chain.\n\nPyth prices come from firstparty data. Accurate, clean, compliant.\n\nPyth prices are valuable. Live US equities? Bloomberg should be afraid.\n\n...\n\nWhat is Pythnet?\n\n\nPythnet is an appchain based on the Solana codebase\n\nPythnet allows Pyth to scale by 20x to thousands of price feeds\n\nPythnet allows Pyth to deliver pricing to other chains via Wormhole\n\nPythnet separates Pyth's uptime and performance from Solana\n\n...\n\nWhat do you get when you combine Pythnet and Wormhole?\n\n\nPythnet Price Feeds: A new price oracle model\n\nThe other acceptable answer was: Magic and miracles\n...\n\nWhat is a Push Oracle?\n\n\nA push oracle can provide realtime updates to a blockchain environment without the need for a smart contract to initiate a request for that data.\n\nA push oracle continually \u201cpushes\u201d onchain price updates at a set frequency\n\n...\n\nWhat is a Pull Oracle?\n\n\nA pull oracle operates by waiting for requests from a smart contract before providing data.\n\nWhen a smart contract needs to retrieve data from a pull oracle, it sends a request to the oracle, which then provides the data to the contract.\n\n...\n\nPyth is now a lowlatency pull oracle. What does this mean?\n\n\nPyth allows applications to \"pull\" data from Pythnet to their native blockchain whenever they want. The applications pay for the data they use.\n\nPyth does not require someone to pay for a stream of price updates to every blockchain (including the price updates that no one uses). The pull oracle model is very gas efficient.\n\nThe gas efficiency of the Pyth pull oracle architecture allows for highfrequency price updates (Pythnet can update without sending data to new chains).\n\nThe gas efficiency of the Pyth pull oracle architecture allows for lowlatency prices (apps pull the freshest prices instead of waiting for pushes/heartbeats).\n\nThe Pyth pull oracle architecture allows all 200+ Pyth price feeds to be on every blockchain at once. Apps on different chains all pull from one \"offchain\" source: Pythnet.\n...\n\nPyth offers the same 200+ price feeds on every chain. Other oracles can't do this. Why does this matter?\n\nSummary answer: This is great for teams who want to go multichain. They can access the same markets anywhere they build.\n\n...\n\nWhen Pyth spins up a price feed on one blockchain, it is immediately available on all 17+ other Pythsupported chains. Why would DeFi teams find this exciting?\n\nTeams who spin up their own price feeds with Pyth can thereby extend exposure to that asset in 18+ blockchains. Few people understand this.\n\n...\n\nA lot of applications out there are now #PoweredByPyth. Why should you start using Pythpowered applications as much as possible?\n\n\nPyth has many virtues. We leave it to everyone to discuss.", "doc_id": "8f9bddbd-80ff-4173-a15a-2bdefb33422e", "embedding": null, "doc_hash": "ad434b70c9bb5bdd73a8e23fa73fac17d65fd3409a3dedfefb126de7bce2c6c9", "extra_info": null, "node_info": {"start": 27522, "end": 30959}, "relationships": {"1": "30b68589-8f48-4b65-a859-6fd104de5cbb", "2": "41002785-c66f-41d4-aa4c-417da94dc5ae"}}, "__type__": "1"}, "4fd5078f-f0c8-47d5-9258-849631610897": {"__data__": {"text": "\ufeffLast October, the Pyth network made a bold declaration: that Pyth is going cross-chain, with a longer-term vision to become a fully self-sustaining, decentralized oracle network as envisioned in the whitepaper.\nOne quarter into 2023, and the results speak for themselves. Industry leaders from more than 18 blockchains trust and rely on Pyth prices for their operations, from Synthetix on Optimism to Ribbon Finance on Ethereum, CAP Finance on Arbitrum to Deri Trade on BNB Chain. Even TradingView themselves, an off-chain and massively popular charting tool, is plugged into Pyth data!\nIt\u2019s been a fruitful Q1, and a lot of hard work for the Pyth community over the past six months. It can be dizzying keeping up with the network\u2019s breakneck growth.\nWe\u2019re writing to give everyone comprehensive recap, and comment on some interesting trends in DeFi, before wrapping up with Pyth\u2019s governance progress and sharing some exciting community events\u2026\n________________\n\n\nWhat is Pyth\nSome readers may be new to the Pyth network. If so, welcome! Pyth delivers real-time market data to 15+ blockchains. Pyth supports 230+ price feeds across crypto, equities, FX pairs, and commodities, sourced from some of the biggest exchanges and market makers.\nPyth is unique among oracles in that it sources all of its data from institutional, first-party sources like CBOE, Jane Street, TwoSigma, Binance, OKX, and Bybit. In contrast, legacy oracle designs require smart contract developers to pay intermediary nodes for the service of scraping data from third-party sources like CoinGecko or CoinMarketCap.\n  \n\nThe critical assumption with legacy models is that all Web2 data is free and you simply need to incentivize nodes to scrape it. Pyth\u2019s assumption is that the data owners should be compensated appropriately for the usage of their proprietary data.\nThe Pyth network\u2019s mission is to deliver data that the blockchain community can trust. When robust, cutting-edge infrastructure is in place, a nascent industry like decentralized finance can experience a second phase of explosive growth. After the vicissitudes of 2022, a paradigm shift for blockchain is long overdue.\n________________\n\n\nHow it Started, How it\u2019s Going\nPyth V1: Solana Price Feeds\nPyth had its beginnings in Solana. On August 26, 2021, the Pyth network launched into mainnet with 25 data providers supplying their proprietary price data to the Pyth on-chain program on Solana with a little more than 40 price feeds.\nGrowth was rapid. By March 2022, Pyth secured over 90% of Solana\u2019s value and supported over $3.7B in total trading volume, demonstrating clear and overwhelming demand for Pyth data. The network welcomed onboard more than 50 data providers, offered almost 60 price feeds, and had generated approximately 10M daily market updates in those 6 months\u2014an unthinkable feat for blockchain. The world started taking notice.\nMotivations for Supporting a Multi-Chain World\nAs the crypto ecosystem began evolving in a multi-chain direction, the next major step for Pyth was sending Pyth prices to every blockchain. We recognized that developers will need access to reliable, real-time data, no matter where they choose to build or expand to. Furthermore, Web3 in the longer-term will have to abstract away the complexities of what blockchain a dApp is operating from or transacting with: it is difficult to imagine decentralized finance becoming widely adopted otherwise.\nOf course, an oracle that scales to the needs of a multi-chain future must also maintain the security and resiliency expectations of both decentralized and even traditional finance. The systemic shocks throughout crypto last year confirmed the need for even greater protocol security and unfailingly robust infrastructure.\nFrom this vision, we forged Pythnet, and thus launched Pyth V2 on August 2022\u2014an innovative oracle solution designed to scale with the growth of Web3 and equip", "doc_id": "4fd5078f-f0c8-47d5-9258-849631610897", "embedding": null, "doc_hash": "2bcfb04865007f8bee9062b252731498f37cc0a54fdc02401a37d7c0e55c8ae8", "extra_info": null, "node_info": {"start": 0, "end": 3915}, "relationships": {"1": "6218bb9b-73d8-4850-9f6f-dd5196c0068c", "3": "341cac73-f258-4234-a223-c20f83123730"}}, "__type__": "1"}, "341cac73-f258-4234-a223-c20f83123730": {"__data__": {"text": "need access to reliable, real-time data, no matter where they choose to build or expand to. Furthermore, Web3 in the longer-term will have to abstract away the complexities of what blockchain a dApp is operating from or transacting with: it is difficult to imagine decentralized finance becoming widely adopted otherwise.\nOf course, an oracle that scales to the needs of a multi-chain future must also maintain the security and resiliency expectations of both decentralized and even traditional finance. The systemic shocks throughout crypto last year confirmed the need for even greater protocol security and unfailingly robust infrastructure.\nFrom this vision, we forged Pythnet, and thus launched Pyth V2 on August 2022\u2014an innovative oracle solution designed to scale with the growth of Web3 and equip builders on every chain with the mission-critical tooling necessary for the highest protocol performance.\nPyth V2: A New Low-Latency Pull Oracle\nPythnet is an application-specific blockchain (appchain) built on the Solana codebase. This blockchain uses the same software, but is completely separate from the Solana mainnet environment.\nMuch like in the Solana Price Feeds design, Pyth\u2019s data providers submit their first-party prices to the Pyth program on Pythnet for aggregation. On top of this, Pythnet provides enables some powerful advantages:\nFirstly, Pythnet allows the Pyth network to scale by 20x to support thousands of price feeds and perform tens of thousands of price updates per second.\nSecondly, Pythnet\u2019s performance is independent of Solana mainnet, adding an additional redundancy layer to Pyth\u2019s resiliency design.\nThirdly, Pythnet is publicly auditable using widely available tools like Dune Dashboard, TradingView, and the Solana Block Explorer: a stark contrast to legacy opaque P2P models.\nFourthly\u2014and most importantly\u2014Pythnet allows the network deliver prices to other blockchains through Wormhole, the cross-chain messaging protocol.\nWith Pythnet and Wormhole in place, the network could launch Pythnet Price Feeds, which introduced a unique low-latency pull oracle design.\nMost other oracles (including Pyth\u2019s Solana Price Feeds) utilize a push model and continually \u201cpush\u201d on-chain price updates at a set frequency. In contrast, Pyth allows users to \u201cpull\u201d prices from Pythnet to their native chain on demand.\nThis new pull model enables Pyth network to deliver higher-frequency updates price updates\u2014once per second, faster than the block time of most blockchains. Users also benefit lower latencies: they can use the most recent off-chain (Pythnet) price, instead of relying on the last on-chain update pushed by the oracle.\nThe speed, scalability, and latency advantages described above are made possible thanks to the gas costs savings of Pyth\u2019s on-demand oracle design. Compare the Pyth pull-based design to push oracles, which must pay gas fees for every price update, including updates that no one will use, and incur additional transaction costs for supporting new price feeds or additional blockchains.\n  \n\nPythnet Price Feeds were designed for scaling. And scale it did. Pyth\u2019s low-latency pull oracles now serve applications across10+ EVM blockchains, Aptos, Cosmos Hub, and more. Let\u2019s take a look at Pyth\u2019s growth since V2\u2019s launch.\n________________\n\n\nLooking at the Numbers\nThe DeFi Ecosystem is Calling on Pyth\nTo date, the new Pyth on-demand price update model has already delivered over 800K price updates on-chain to #PoweredByPyth applications across over a dozen blockchains. On March 12 alone, Pyth received more than 25K price pull requests.\nWith this explosive growth in on-chain activity, Pyth V2 has proven to be a resounding success in the broader ecosystem.\n  \n\nNew Blockchains: Pyth Data Everywhere\nWe\u2019ve come far since April 2021, when Pyth started in Solana. The network made big moves upon deploying Pythnet to scale Pyth data to", "doc_id": "341cac73-f258-4234-a223-c20f83123730", "embedding": null, "doc_hash": "69c14959caf11531d38df45b27b893f85460b68fe1460d888f36e3e704fe7c1c", "extra_info": null, "node_info": {"start": 3233, "end": 7126}, "relationships": {"1": "6218bb9b-73d8-4850-9f6f-dd5196c0068c", "2": "4fd5078f-f0c8-47d5-9258-849631610897", "3": "31bfb2f7-0539-47dd-b99a-cc206e4da6e1"}}, "__type__": "1"}, "31bfb2f7-0539-47dd-b99a-cc206e4da6e1": {"__data__": {"text": "Aptos, Cosmos Hub, and more. Let\u2019s take a look at Pyth\u2019s growth since V2\u2019s launch.\n________________\n\n\nLooking at the Numbers\nThe DeFi Ecosystem is Calling on Pyth\nTo date, the new Pyth on-demand price update model has already delivered over 800K price updates on-chain to #PoweredByPyth applications across over a dozen blockchains. On March 12 alone, Pyth received more than 25K price pull requests.\nWith this explosive growth in on-chain activity, Pyth V2 has proven to be a resounding success in the broader ecosystem.\n  \n\nNew Blockchains: Pyth Data Everywhere\nWe\u2019ve come far since April 2021, when Pyth started in Solana. The network made big moves upon deploying Pythnet to scale Pyth data to the wider DeFi ecosystem. Pyth first went live on BNB Chain in the beginning of October 2022, and in half a year, expanded to Ethereum, Arbitrum, Optimism, zkSync Era, Polygon zkEVM, Base, Aptos, and Injective (Cosmos Hub), just to name a few.\nThe list of supported chains is bigger than most readers might realize! As of April, Pyth is available on 18 blockchains.\nIn line with April\u2019s festivities, we\u2019re giving away some website easter eggs: you can find the full list of Pyth-supported blockchain environments here. (Can you find the other surprises in our website?)\n  \n\nNew Users: Everyone Wants Pyth Data\nExpanding to new blockchains is one thing, but usage by smart contract is the real test of \u2018product-market fit\u2019. Don\u2019t take our word for it: you can ask the contributors behind Synthetix how Pyth data has made their perps more competitive, and allowed their platform to reduce fees to 5-10 bps and support 23 new markets. The Synthetix ecosystem is now following suit, with Polynomial, Kwenta and Decentrex also becoming #PoweredByPyth. Optimism is in the air!\nThe astute Pythian will also have noticed that new blockchain expansion announcements means new Pythian launch partners. Be sure to say hello to 0VIX, the premier liquidity market protocol on Polygon\u2019s zkEVM. We\u2019re also excited to work with Nexon, an innovative lending provider, and Derivio, a structured derivatives ecosystem, on zkSync Era!\nWe also want to give a shoutout to the Injective ninjas. We\u2019re excited to support the fastest blockchain built for finance. Helix, an exciting DEX on Injective, is launching a variety of markets across forex, crypto, and metals thanks to Pyth.\nNew builders in familiar ecosystems are coming out of the woodwork and making good use of Pyth Price Feeds. Some of them are lowkey OG\u2019s, like CAP Finance, whose V4 perps are taking Arbitrum by storm, while upstarts like Poison Finance, the synthetics protocol, have emerged to democratize asset management. Traders rejoice, as Perpy Finance and Tigris are also here to help you copy trade and obtain up to 500x leverage.\nMeanwhile on BNB Chain, Uniwhale and Level Finance are leveraging Pyth for their perpetuals futures. DEXs like DeriTrade and Meuna are also excited to bring RWA exposure to the masses thanks to Pyth\u2019s wide asset class coverage. Nevertheless, not all use cases in BNB Land are high leverage and high intensity: the stableswap Wombat Exchange, for example, uses Pyth for their analytics.\nIn the MOVE world, you can find the borrow-lending platforms Aries Markets and Aptin, as well as hyper-app Thala Labs serving the Aptos ecosystem. You may have even heard rumors of Pyth moving into Sui\u2026\nBack in our homestead, Solana, you\u2019ll find that the builder\u2019s ethos has not wavered: Elusiv, a zero-knowledge privacy protocol, is making clever use of our Solana Price Feed; you can", "doc_id": "31bfb2f7-0539-47dd-b99a-cc206e4da6e1", "embedding": null, "doc_hash": "5cb2cbad24d0c5159430c07b2d9691a704309af3cdbaf15eb76f0a478143f667", "extra_info": null, "node_info": {"start": 7220, "end": 10770}, "relationships": {"1": "6218bb9b-73d8-4850-9f6f-dd5196c0068c", "2": "341cac73-f258-4234-a223-c20f83123730", "3": "03a7ddd0-208d-49c2-a438-29177d70ff75"}}, "__type__": "1"}, "03a7ddd0-208d-49c2-a438-29177d70ff75": {"__data__": {"text": "perpetuals futures. DEXs like DeriTrade and Meuna are also excited to bring RWA exposure to the masses thanks to Pyth\u2019s wide asset class coverage. Nevertheless, not all use cases in BNB Land are high leverage and high intensity: the stableswap Wombat Exchange, for example, uses Pyth for their analytics.\nIn the MOVE world, you can find the borrow-lending platforms Aries Markets and Aptin, as well as hyper-app Thala Labs serving the Aptos ecosystem. You may have even heard rumors of Pyth moving into Sui\u2026\nBack in our homestead, Solana, you\u2019ll find that the builder\u2019s ethos has not wavered: Elusiv, a zero-knowledge privacy protocol, is making clever use of our Solana Price Feed; you can also lever up with PsyLend and mrgnlend as things heat up in Rust-land.\nThe list is never-ending and a comprehensive guide would be encyclopaedic. We recommend you also check out Morphex, the spot and futures DEX on Fantom; Fulcrom, the perps exchange on Cronos; Aurigami, the lending platform on Aurora, and many, many more.\nLast, but not least, we\u2019re elated to see Pyth data now integrated into TradingView, the leading chart platform trusted by 50M+ traders and investors globally.\n  \n\nDelivering The Prices You Need\nPyth now supports more than 230 price feeds across major asset classes, with many more still in the pipeline!\nNot only that, but every Pyth price feed is automatically available on all supported blockchains. Unlike legacy oracles, Pyth does not need to spin up a new feed one-by-one on every blockchain it wants to expand to.\nHaving readily available data feeds on every chain makes all the difference for builders. Pyth helps developers deploy faster, seize multi-chain growth opportunities, and strategically extend exposure to their own protocol to new blockchain ecosystems.\nWe can\u2019t wait to reveal the newest asset types the network will soon support! Suffice to say, we\u2019ve received substantial interest from teams looking to work with treasury rates, energy prices, and even international equities.\n  \n\nLater in March, Pyth demonstrated its unwavering dedication to agility and rapidity in delivering price feeds to those in need, and the world took notice. Thanks to the amazing effort of our data providers, the Pyth network launched its ARB/USD feed mere hours after the $ARB started trading on-chain!\nOur ability to spin up new price feeds rapidly means that teams like CAP Finance (Arbitrum), Uniwhale (BNB Chain), Drift (Solana), Zeta Markets, Vyper, Tigris Trade (Arbitrum), and of course, Synthetix (Optimism) could quickly launch their $ARB perpetual futures to meet the surge in demand from traders\u2014many of them on that same day!\nPyth Driving Serious Volume\nPyth is now close to supporting over $40B in total trading volume throughout its lifetime.\nLet\u2019s reflect on some recent trends in trading volume. The $ARB drop, combined with volatility from the recent events of SVB and Signature Bank, brought new all-time-highs in volume across our #PoweredByPyth perpetual partners. Synthetix themselves began seeing daily volumes of up to $200M and $1.5B in total trading volume, resulting in a whopping $1.5M in fees!\nThe other stars of the show include Perpy Finance (Arbitrum), CAP Finance, Uniwhale Drift, HXRO (Solana), Cypher, and Fulcrom (Cronos)\u2014each one achieving their own ATH\u2019s across their Pyth-powered perpetual markets!\n  \n\nNew Products\nBenchmarks\nHistorical Pyth data is finally here. Users can leverage our new Pyth Benchmarks to access historical Pyth market data, and soon, other types of standardized data.\nPyth Benchmarks cover all 200+ assets supported by the network.", "doc_id": "03a7ddd0-208d-49c2-a438-29177d70ff75", "embedding": null, "doc_hash": "7f19f3eb5966d505980636d1100e04b2150f73a0da737ace2fa0e33633189e3d", "extra_info": null, "node_info": {"start": 10782, "end": 14393}, "relationships": {"1": "6218bb9b-73d8-4850-9f6f-dd5196c0068c", "2": "31bfb2f7-0539-47dd-b99a-cc206e4da6e1", "3": "8f608bcd-4d1a-4481-96e4-3a49e3a65a38"}}, "__type__": "1"}, "8f608bcd-4d1a-4481-96e4-3a49e3a65a38": {"__data__": {"text": "in volume across our #PoweredByPyth perpetual partners. Synthetix themselves began seeing daily volumes of up to $200M and $1.5B in total trading volume, resulting in a whopping $1.5M in fees!\nThe other stars of the show include Perpy Finance (Arbitrum), CAP Finance, Uniwhale Drift, HXRO (Solana), Cypher, and Fulcrom (Cronos)\u2014each one achieving their own ATH\u2019s across their Pyth-powered perpetual markets!\n  \n\nNew Products\nBenchmarks\nHistorical Pyth data is finally here. Users can leverage our new Pyth Benchmarks to access historical Pyth market data, and soon, other types of standardized data.\nPyth Benchmarks cover all 200+ assets supported by the network. Industry leaders like Ribbon Finance, the premier DOV on Ethereum, Solana and Avalanche, is leveraging Pyth Benchmarks to settle its weekly options every Friday at 8:00 AM UTC. Benchmarks allows Ribbon to retrieve exact settlement prices within seconds of expiry and settle instantly.\nBenchmarks represent a major step for decentralized finance. In the traditional financial world, there exists a number of universally accepted standards (or \u201cbenchmarks\u201d), including reference prices (e.g. Bitcoin reference rate), indices (e.g. the S&P500), and reference rates (e.g. LIBOR). Few such standards exist within the realms of crypto or DeFi. We hope that our Benchmarks will, at the very least, drive conversation around blockchain transparency and empower market participants with more thoughtful choices in the data sources which shape their decision-making. You can read more here.\nLiquidity Oracle\nWe\u2019re also excited to have launched the V1 of the Pyth Liquidity Oracle in collaboration with Kaiko, one of our data provider partners and a leader in cryptocurrency market data.\nBringing liquidity information on-chain, on top of price data, can help protect lending platforms and money market protocols from liquidity exploits as seen with Aave or Mango Markets. We designed the Pyth Liquidity Oracle V1 to help users mitigate the risks inherent in large positions of illiquid tokens. You can read more about our initial research on liquidity oracles and get started with our V1 solution here.\n________________\n\n\nGet Started with Pyth\nUnlock the full potential of your application with Pyth data, and gain the edge you deserve. Integrating with Pyth data feeds is seamless and easy.\nYou can explore our documentation to learn more about how Pyth\u2019s unique design can secure your protocol with real-time, on-demand price data:\n* How Pyth Network Works\n* On-Demand Updates\nYou can explore our catalog of price feeds here:\n* Pythnet Price Feeds (for Aptos, BAS, Coswasm, EVM)\n* Solana Price Feeds\nFollow along with our integration tutorials:\n* Integrate on EVM (On-Demand)\n* Integrate on EVM (with Pusher)\n* Integrate on Other Chains or Off-Chain\nhttps://youtu.be/qdwrs23Qc9g\nWhat\u2019s Coming Next\nOur mission remains the same. Pyth will continue expanding cross-chain through Wormhole to support builders across the wider decentralized finance and Web3 ecosystem. Supporting developers with the requisite training, tooling, and guidance is top of mind for the network\u2019s contributors, and we\u2019re eager to announce more on this front.\nWe also look forward to sharing a number of exciting developments focused on making the Pyth network fully self-sustaining and decentralized. If you have any feedback or ideas, please feel free to reach out in our Discord. Those especially interested in protocol governance and network security can keep track of the continuous and rigorous auditing of our cross-chain and governance contracts.\nWe\u2019ve come a long way together on our journey towards fairer and more transparent markets, governed by users and serving individuals and institutions alike. And yet, we\u2019re still so early.", "doc_id": "8f608bcd-4d1a-4481-96e4-3a49e3a65a38", "embedding": null, "doc_hash": "bda5ca074f6a92da140ec31393aa0ba45a08fe04938d08ee65338d07216e304c", "extra_info": null, "node_info": {"start": 14309, "end": 18080}, "relationships": {"1": "6218bb9b-73d8-4850-9f6f-dd5196c0068c", "2": "03a7ddd0-208d-49c2-a438-29177d70ff75"}}, "__type__": "1"}, "84857449-6650-4741-ac5b-0711508b8a5c": {"__data__": {"text": "P Y T H N E T W O R K : A\nF I R ST- PA RTY F I N A N C I A L\nO R A C L E\n/p.sc/y.sc/t.sc/h.sc /d.sc/a.sc/t.sc/a.sc /a.sc/s.sc/s.sc/o.sc/c.sc/i.sc/a.sc/t.sc/i.sc/o.sc/n.sc\n/v.sc/e.sc/r.sc/s.sc/i.sc/o.sc/n.sc /one.taboldstyle./zero.taboldstyle\nJanuary 4th,2022\nFinancial market data is often only accessible to a limited set of institutions and\nusers. Traditional markets typically maintain strict control over live and historical\nprice feeds. Cryptocurrency markets currently have fewer barriers, although there\nis no guarantee this arrangement will continue. Consequently, only a selected group\nof users has access to the most timely, accurate, and valuable information.\nThe Pyth network aims to bring this valuable \ufb01nancial market data to DeFi ap-\nplications and the general public. The network does so by incentivizing market\nparticipants \u2014 trading \ufb01rms, market makers, and exchanges \u2014 to share the price\ndata collected as part of their existing operations. The network aggregates this\n\ufb01rst-party price data and publishes it on-chain for use by either on- or off-chain\napplications.\nThe Pyth network has already made substantial progress toward this goal. An\ninitial version of the protocol is running on the Solana network, where it provides\nsub-second price updates for US equities, foreign currency pairs, commodities, and\ncryptocurrencies. The network\u2019s data providers include many prominent trading\n\ufb01rms and exchanges in the traditional \ufb01nance and cryptocurrency spaces. The\nnetwork\u2019s price feeds already power some of the leading protocols on Solana and\nwill soon be available on other blockchains.\nThis whitepaper aims to expand on the design of the protocol that powers the\nPyth network. The goal of the design is to make the Pyth network self-sustaining\nand decentralized. The protocol consists of a system of mechanisms and incentives\nthat coordinate the participants in the network.1This whitepaper describes the roles\nof the participants in the network and the mechanisms that coordinate them.\nThe Pyth Data Association (the \u201cAssociation\u201d), in collaboration with the com-\nmunity of Pyth network participants, has published this whitepaper to describe\na vision for the future of the Pyth network. The Association and network partic-\nipants will guide initial development of the protocol based on the ideas in this\nwhitepaper, feedback from the broader crypto community, and governance input\nfrom PYTH token-holders.\n/one.taboldstyle /o.sc/v.sc/e.sc/r.sc/v.sc/i.sc/e.sc/w.sc\nThe Pyth protocol is designed to incentivize participants to continuously publish\nprice updates for various products (such as BTC/USD). Each product has a price feed\n1In this whitepaper, the term \u201cnetwork\u201d refers to a speci\ufb01c instantiation of the Pyth protocol and its par-\nticipants. When an action is performed by the \u201cPyth network,\u201d it is in fact performed by the participants\ninteracting with the protocol instance.\n1", "doc_id": "84857449-6650-4741-ac5b-0711508b8a5c", "embedding": null, "doc_hash": "9d320b7423fdf9c792c11623cd867a4b4b46694386685d0148bec06c303ac188", "extra_info": {"page_label": "1"}, "node_info": {"start": 0, "end": 2908}, "relationships": {"1": "f28aa417-b07f-486c-a511-3f9a43761b6b"}}, "__type__": "1"}, "19cdbe59-617e-4906-a1d4-02103ed75e10": {"__data__": {"text": "/o.sc/v.sc/e.sc/r.sc/v.sc/i.sc/e.sc/w.sc 2\nFigure 1: Overview of the Pyth protocol depicting the participants (purple ovals) and their\ninteractions with various mechanisms (purple circles). See text for more details on\neach mechanism.\nthat continuously updates with its current price and a con\ufb01dence interval represent-\ning the estimated uncertainty of the price. For example, the current BTC/USD feed\nmay say the price is $65000 \u0006$50. The feed for each product is published on-chain,\nwhere it is read by consumers , who may be either blockchain-enabled programs or\noff-chain applications. An on-chain program produces the price feed for each prod-\nuct by aggregating the price feeds of individual publishers . The protocol is designed\nto attract publishers who are \ufb01rst-party data providers with the ability to source\nhigh-quality, timely pricing information.\nIn addition to publishing these price feeds, the Pyth protocol will allow con-\nsumers to optionally pay data fees. In exchange for these fees, consumers may\nreceive a payout from delegators if the oracle price is inaccurate. Data fees enable\nprojects that use the protocol\u2019s prices to hedge against oracle inaccuracies on behalf\nof their users. A share of data fees go to publishers, which enables them to monetize\ntheir data.\nThus, the protocol will have three different sets of participants:\n\u000fPublishers publish price feeds and earn a share of data fees in exchange. Pub-\nlishers are typically market participants with access to accurate and timely\nprice information. The protocol rewards publishers in proportion to the quan-\ntity of new pricing information that they share.\n\u000fConsumers read price feeds, incorporate data into smart contracts or dApps,\nand optionally pay data fees. Consumers can either be on-chain protocols or\noff-chain applications.\n\u000fDelegators stake tokens and earn data fees in exchange for potentially losing\ntheir stake if the oracle is inaccurate.", "doc_id": "19cdbe59-617e-4906-a1d4-02103ed75e10", "embedding": null, "doc_hash": "de512c1171660edf538681c235d030088e3554939171ec0a452a29bbd74760ac", "extra_info": {"page_label": "2"}, "node_info": {"start": 0, "end": 1935}, "relationships": {"1": "045752ab-dfa7-4e4e-802d-b494c34ec553"}}, "__type__": "1"}, "e2366871-23de-49de-9733-872cc99b675a": {"__data__": {"text": "/p.sc/r.sc/i.sc/c.sc/e.sc /a.sc/g.sc/g.sc/r.sc/e.sc/g.sc/a.sc/t.sc/i.sc/o.sc/n.sc 3\nNote that a single actor may have multiple roles in the protocol; for example,\npublishers may simultaneously be delegators.\nThese participants will interact via four mechanisms. All of these mechanisms\nwill be implemented on-chain:\n\u000fPrice aggregation combines the price feeds of individual publishers into a sin-\ngle price feed for the product. This mechanism is designed to produce robust\nprice feeds, that is, feeds whose prices cannot be signi\ufb01cantly in\ufb02uenced by\nsmall groups of publishers.\n\u000fData staking allows delegators to stake tokens to earn data fees. The dele-\ngators in aggregate also determine the level of in\ufb02uence that each publisher\nhas on the aggregate price. In addition, this mechanism determines whether\ndelegators\u2019 stakes are slashed. Finally, the mechanism collects data fees from\nconsumers and distributes a share to delegators. The remainder goes into a\nreward pool that is distributed to publishers.\n\u000fReward distribution determines the share of the reward pool earned by each\npublisher. This mechanism preferentially rewards publishers with higher-\nquality price feeds and reduces the likelihood that uninformed publishers\nwill earn rewards.\n\u000fGovernance determines high-level parameters of the other three mechanisms.\nA critical challenge is designing these mechanisms to be robust to various forms\nof adversarial behavior. Three speci\ufb01c attacks to consider are:\n1. Participants could onboard as publishers and attempt to manipulate the oracle\nprice. The price aggregation mechanism is designed to guard against this\nattack by limiting the in\ufb02uence of publishers on the aggregate price.\n2. Uninformed participants could onboard as publishers to earn rewards with-\nout contributing useful pricing information. The reward distribution mecha-\nnism is designed to guard against this attack by reducing the possibility that\nuninformed participants can earn rewards.\n3. Participants could pay data fees and seek to manipulate the claims process\nto trigger an invalid payout. The mechanism\u2019s claims process is designed to\nmake this attack dif\ufb01cult.\nThe mechanisms introduced above will depend on two core functions of the pro-\ntocol. First, parts of the Pyth protocol will run in epochs. An epoch is a number\nof Solana slots corresponding to one week of real-time. Second, the protocol will\nrequire users to stake PYTH tokens to participate in some activities. Staking locks\nthe user\u2019s tokens immediately and makes them available for downstream activities\nat the beginning of the next epoch. At any point, stakers can request to unstake\ntheir tokens. Upon unstaking, the tokens will remain locked in the contract for the\nremainder of then-current and subsequent epoch. This staking design guarantees\nthat the quantity of PYTH tokens staked toward any given activity remains constant\nwithin an epoch. Additional mechanisms such as stake pools may enable stakers to\ndelegate their staked tokens to another user. However, these mechanisms are not\ncore to the protocol (and could be built as entirely separate programs), so they are\nnot described in this whitepaper.\n/two.taboldstyle /p.sc/r.sc/i.sc/c.sc/e.sc /a.sc/g.sc/g.sc/r.sc/e.sc/g.sc/a.sc/t.sc/i.sc/o.sc/n.sc\nThe price aggregation mechanism combines each individual publisher\u2019s price and\ncon\ufb01dence feed into a single aggregate price and con\ufb01dence", "doc_id": "e2366871-23de-49de-9733-872cc99b675a", "embedding": null, "doc_hash": "925cc37a268502b47f74602a9def0d70282266a9641c25f809430c95ded6ac76", "extra_info": {"page_label": "3"}, "node_info": {"start": 0, "end": 3401}, "relationships": {"1": "6d66ba0d-47e8-4d92-b1b6-1b47f88d1954", "3": "778ed795-0164-4a89-a15a-803e29e8a4b0"}}, "__type__": "1"}, "778ed795-0164-4a89-a15a-803e29e8a4b0": {"__data__": {"text": "tokens staked toward any given activity remains constant\nwithin an epoch. Additional mechanisms such as stake pools may enable stakers to\ndelegate their staked tokens to another user. However, these mechanisms are not\ncore to the protocol (and could be built as entirely separate programs), so they are\nnot described in this whitepaper.\n/two.taboldstyle /p.sc/r.sc/i.sc/c.sc/e.sc /a.sc/g.sc/g.sc/r.sc/e.sc/g.sc/a.sc/t.sc/i.sc/o.sc/n.sc\nThe price aggregation mechanism combines each individual publisher\u2019s price and\ncon\ufb01dence feed into a single aggregate price and con\ufb01dence feed. For example, one", "doc_id": "778ed795-0164-4a89-a15a-803e29e8a4b0", "embedding": null, "doc_hash": "894d5e4c2a022fa7ab4595b02bc9245d0726162f693f873b1b40ea6c55f16900", "extra_info": {"page_label": "3"}, "node_info": {"start": 2828, "end": 3424}, "relationships": {"1": "6d66ba0d-47e8-4d92-b1b6-1b47f88d1954", "2": "e2366871-23de-49de-9733-872cc99b675a"}}, "__type__": "1"}, "fe4cb3c8-8442-433a-81a0-60a646d91412": {"__data__": {"text": "/p.sc/r.sc/i.sc/c.sc/e.sc /a.sc/g.sc/g.sc/r.sc/e.sc/g.sc/a.sc/t.sc/i.sc/o.sc/n.sc 4\nFigure 2: Scenarios for the aggregation procedure. The lower thin bars represent each pub-\nlisher\u2019s prices and con\ufb01dence intervals, and the bold red bar represents the result-\ning aggregate price and con\ufb01dence.\npublisher may say that the price of BTC/USD is $52000 \u000610 and another that it is\n$53000\u000620, and price aggregation may combine these two prices into an aggregate\nprice of $52500\u0006500. This mechanism is part of the on-chain program and trig-\ngers when publishers submit price updates: the \ufb01rst price update on a given slot\nautomatically aggregates the prices from the previous slot.\nThe price aggregation algorithm is designed to have three properties:\n1. It is resistant to manipulation \u2014 both accidental and intentional \u2014 by publish-\ners. For example, if most publishers submit a price of $ 100and one publisher\nsubmits a price of $ 80, the aggregate price remains near $ 100. This property\nincreases the likelihood that the aggregate price remains accurate even if a\nsmall percentage of publishers submit a price far from the market. Figure 2(a)\ndepicts this scenario.\n2. The aggregate price appropriately weights data sources with different levels of\naccuracy. The Pyth protocol allows publishers to submit a con\ufb01dence interval\nbecause they have varying levels of accuracy in observing the price of a prod-\nuct. For example, some publishers are expected to be exchanges. Exchanges\nhave different levels of liquidity, and less liquid exchanges tend to have wider\nbid/offer spreads than more liquid ones. This property can result in situations\nwhere one exchange reports $101 \u00061, and another reports $110 \u000610. In these\ncases, the aggregate price is closer to $ 101than $ 110. Figure 2(b) depicts this\nscenario.\n3. The aggregate con\ufb01dence interval re\ufb02ects the variation between publishers\u2019\nprices. In reality, there is no single price for any given product. Products\ntrade at slightly different prices at various venues at any given time. Fur-\nthermore, the product\u2019s spread is a fundamental limit on the precision of the\nproduct\u2019s price. The aggregate con\ufb01dence interval re\ufb02ects both the variation\nacross venues and these limitations. Figures 2(c) and (d) depict two different\ncases where there are price variations across exchanges.\nThe price aggregation algorithm uses a variant of the weighted median. An input\nto the algorithm is a stake-weight for each publisher. The data staking mechanism\n(described below) generates this weight to maximize the robustness of the price feed.\nThis weight is designed to account for hard-to-quantify factors that may in\ufb02uence\nrobustness, such as publisher reputation. The \ufb01rst step of the algorithm computes\nthe aggregate price by giving each publisher three votes \u2013 one vote at their price and\none vote at each of their price plus and minus their con\ufb01dence interval \u2013 then taking\nthe stake-weighted median of the votes. The second step computes the distance\nfrom the aggregate price to the stake-weighted 25th and 75th percentiles of the\nvotes, then selects the larger as the aggregate con\ufb01dence interval.\nThis simple algorithm is a generalization of the ordinary median. Most people un-\nderstand the median as the middle value in the data set, that is, the 50th percentile.\nHowever, the median is also the value Rthat minimizes the objective function\n\u00e5ijR\u0000pijwhere piis the price of the ith publisher. This function penalizes Rbased\non its distance from the publisher\u2019s price pi. The proposed algorithm computes the", "doc_id": "fe4cb3c8-8442-433a-81a0-60a646d91412", "embedding": null, "doc_hash": "70dc69db9fcb4a43099976fd445a70ce0c4a236f860043109359d27bd391665c", "extra_info": {"page_label": "4"}, "node_info": {"start": 0, "end": 3549}, "relationships": {"1": "e35bb485-9070-4e17-8883-d1bb2007e2b8"}}, "__type__": "1"}, "d6f2127b-7906-4378-b7af-d19e27fa2f84": {"__data__": {"text": "/d.sc/a.sc/t.sc/a.sc /s.sc/t.sc/a.sc/k.sc/i.sc/n.sc/g.sc 5\naggregate price Rthat minimizes1\n3SisijR\u0000pij+2\n3Sisimax(jR\u0000pij\u0000ci, 0), where\nsiis the publisher\u2019s stake-weight and ciis the publisher\u2019s con\ufb01dence interval. This\nobjective does two different things. First, it weights publishers according to their\nstake, such that low-stake publishers have minimal in\ufb02uence on the price. Second,\nit combines the ordinary median objective with a second term that only assigns a\npenalty to Rif it lies outside the publisher\u2019s con\ufb01dence interval.\n/three.taboldstyle /d.sc/a.sc/t.sc/a.sc /s.sc/t.sc/a.sc/k.sc/i.sc/n.sc/g.sc\nThe data staking mechanism collects data fees and distributes payouts if the oracle\npublishes an incorrect price for a product.2The mechanism will also de\ufb01ne a claims\nprocess that determines when consumers receive a data staking payout; this process\ncompares the oracle price to external reference data to measure its accuracy.\nThere are several challenges in designing this mechanism. First, data fees should\nbe fairly priced \u2014 i.e., the price should re\ufb02ect the failure risk. Second, the mecha-\nnism needs to align the incentives of publishers and delegators, as failures on the\npart of publishers could lead to losses for delegators. Finally, the claims process\nneeds to be robust to attempts to trigger payouts on false claims.\nThe data staking mechanism will permit or require users to perform the following\nactions:\n1. Consumers opt to pay data fees for a product. They pay a fee to the Pyth pro-\ntocol in any governance-approved token, which may include PYTH , USDC,\nor other tokens. In exchange, the consumer may earn a payout if the chosen\nproduct has a problem over the next 4epochs (\u00181 month).\n2. Publishers will be required to stake a minimum quantity of PYTH tokens\nper product they price. These PYTH tokens will form a portion of the assets\navailable for payouts but will only be slashed if the publisher publishes an\ninaccurate price. In other words, the protocol will only punish publishers for\nfailures if the on-chain mechanism determines that they are at fault.\n3. Delegators can use their staked PYTH tokens to back products. For each\nstaked PYTH token, delegators select ( 1) the product to back and ( 2) a pub-\nlisher in that product. The publisher selection helps improve the product\u2019s\nsecurity (as described in the text below). Delegators earn a share of the data\nfees for the products they back; governance will determine the share (initially\n80%).\n4. Anyone can raise a claim that the oracle published an incorrect price. Once\nraised, a vote of PYTH token holders rati\ufb01es claims. In the event of a suc-\ncessful claim against the product, the protocol will slash the stakes of the\nproduct\u2019s delegators. The protocol will distribute the slashed amount to con-\nsumers in proportion to the dollar-denominated value of the data fees in the\nepoch during which the event occurred. The process for adjudicating claims is\ndesigned to deem a claim successful if Pyth\u2019s aggregate price and con\ufb01dence\ninterval were substantially incorrect for any period of time. The process will\nfurther determine which publishers were incorrect during this time and slash\ntheir stakes accordingly.\nThis functionality will be implemented as part of the on-chain program that cod-\ni\ufb01es the rules of the Pyth protocol. For example, a consumer will invoke a function\non this program to", "doc_id": "d6f2127b-7906-4378-b7af-d19e27fa2f84", "embedding": null, "doc_hash": "10cab5e7bfa1015928b42f7f953886e48ea41945d3c00ab581db0aa4d5f93912", "extra_info": {"page_label": "5"}, "node_info": {"start": 0, "end": 3390}, "relationships": {"1": "3e6cd561-8e19-4f41-9f34-d6762d0882f7", "3": "ee0fbd82-8dac-4c96-9d89-adee38f850f9"}}, "__type__": "1"}, "ee0fbd82-8dac-4c96-9d89-adee38f850f9": {"__data__": {"text": "of a suc-\ncessful claim against the product, the protocol will slash the stakes of the\nproduct\u2019s delegators. The protocol will distribute the slashed amount to con-\nsumers in proportion to the dollar-denominated value of the data fees in the\nepoch during which the event occurred. The process for adjudicating claims is\ndesigned to deem a claim successful if Pyth\u2019s aggregate price and con\ufb01dence\ninterval were substantially incorrect for any period of time. The process will\nfurther determine which publishers were incorrect during this time and slash\ntheir stakes accordingly.\nThis functionality will be implemented as part of the on-chain program that cod-\ni\ufb01es the rules of the Pyth protocol. For example, a consumer will invoke a function\non this program to hedge product failures. This function will accept payment and\n2Note that this whitepaper does not consider outages, i.e., situations where the oracle fails to publish a\nprice. It may expand in the future to include outages caused by publisher failures and not underlying\nblockchain failures.", "doc_id": "ee0fbd82-8dac-4c96-9d89-adee38f850f9", "embedding": null, "doc_hash": "aeae3cabb17f0213339674b603e25a8adf475008f0cc427bd0f71c202ba99df0", "extra_info": {"page_label": "5"}, "node_info": {"start": 2629, "end": 3682}, "relationships": {"1": "3e6cd561-8e19-4f41-9f34-d6762d0882f7", "2": "d6f2127b-7906-4378-b7af-d19e27fa2f84"}}, "__type__": "1"}, "9e9fa8c6-dc0c-4299-8679-63ee3005ee72": {"__data__": {"text": "/d.sc/a.sc/t.sc/a.sc /s.sc/t.sc/a.sc/k.sc/i.sc/n.sc/g.sc 6\nstore the consumer\u2019s wallet address for future claims payouts. The claims process\ninvolves two separate on-chain actions: raising and ratifying a claim. The former of\nthese actions will require speci\ufb01c input data computed off-chain; the Pyth network\ndevelopers will provide an open-source software package to construct this data. The\nincentives of the claims process are designed to ensure that these off-chain activities\nare performed correctly.\nThis mechanism is intended to produce a market price for data fees. In step ( 3),\ndelegators will compare products on the anticipated data fees relative to the per-\nceived risk of a successful claim. A favorable tradeoff will attract more delegators\nto the product, thereby lowering the price. As this process reaches an equilibrium,\nthe relationship between the fees for a product and its total stake should re\ufb02ect its\nclaim risk.\nDelegators have a secondary role in this process, which is to determine the stake-\nweights of publishers in the aggregation procedure. This process again happens\nin step ( 3) when they select which publisher in the product to back. A publisher\u2019s\nstake-weight is the sum of the publisher\u2019s stake and their backers\u2019 stake, normalized\nsuch that the total stake-weight per product is 1. Note, however, that the delega-\ntors are insuring the product against failures, not the speci\ufb01c publisher \u2014 if the\nother publishers fail, the protocol will still slash the delegator in the resulting claim.\nTherefore, the protocol incentivizes delegators to distribute their stake amongst\npublishers to minimize the product\u2019s overall failure risk. They will need to balance\nmultiple competing factors when making this decision. On the one hand, reputable\npublishers with demonstrated historical performance may warrant a more substan-\ntial stake. On the other hand, distributing stake amongst publishers ensures that a\nsmall number of publisher failures do not cause the product to fail.\nGovernance may allow delegators to back several products with each staked\nPYTH token. This change would make data staking more capital-ef\ufb01cient, as it\nis unlikely that multiple products will have simultaneous successful claims.\n/three.taboldstyle./one.taboldstyle Claims\nThe claims process will determine whether a payout occurs. The purpose of this pro-\ncess is to verify that the aggregate price and con\ufb01dence interval for a product were\nincorrect in comparison to some ground-truth off-chain data. Designing the claims\nprocess is dif\ufb01cult because a successful claim may adversely impact PYTH token-\nholders. Consequently, PYTH token-holders are not impartial judges in this pro-\ncess. On the other hand, an adversary could bribe impartial \u2014 that is, completely\n\ufb01nancially-unmotivated \u2014 judges to trigger an incorrect payout.\nThe proposed claims process reconciles the tension between these two competing\nconcerns. The process will use HUMAN protocol to collect the necessary off-chain\ninformation from impartial judges, then feed that information into a predetermined\nalgorithm that determines the outcome of the claim. PYTH token-holders will then\nvote to ratify the outcome. On rati\ufb01cation, a payout occurs. This mechanism relies\non social pressure to incentivize PYTH token-holders to behave in the long-term\ninterest of the protocol. Intuitively, if PYTH token-holders fail to ratify a payout,\nthen the result of the algorithm is strong evidence to consumers that data fees are\nuseless. Consequently, data fees will stop, and the protocol as a whole is likely to\nfail. However, if an adversary attempts to bribe the judges, PYTH token-holders\ncan vote against", "doc_id": "9e9fa8c6-dc0c-4299-8679-63ee3005ee72", "embedding": null, "doc_hash": "648fcb8e913c02739dd566477298b2a9206e6c4b1bf2536081c1d8852e405661", "extra_info": {"page_label": "6"}, "node_info": {"start": 0, "end": 3674}, "relationships": {"1": "ec90b780-21f8-40a1-9dc3-47b76b55077b", "3": "ce20ff79-db06-4103-b701-cf3b202a1dca"}}, "__type__": "1"}, "ce20ff79-db06-4103-b701-cf3b202a1dca": {"__data__": {"text": "protocol to collect the necessary off-chain\ninformation from impartial judges, then feed that information into a predetermined\nalgorithm that determines the outcome of the claim. PYTH token-holders will then\nvote to ratify the outcome. On rati\ufb01cation, a payout occurs. This mechanism relies\non social pressure to incentivize PYTH token-holders to behave in the long-term\ninterest of the protocol. Intuitively, if PYTH token-holders fail to ratify a payout,\nthen the result of the algorithm is strong evidence to consumers that data fees are\nuseless. Consequently, data fees will stop, and the protocol as a whole is likely to\nfail. However, if an adversary attempts to bribe the judges, PYTH token-holders\ncan vote against rati\ufb01cation and broadcast the evidence of manipulation.\nAnyone will be able to \ufb01le a claim against the protocol to (possibly) trigger a\npayout. A claim is an assertion that the aggregate price and con\ufb01dence interval\nwere incorrect for a speci\ufb01c period of time. To prevent spam, the claimant will be\nrequired to bond some PYTH tokens; the protocol will return the bond if the claim\nis rati\ufb01ed. The claimant will also be required to prepay for the HUMAN task; the\nprotocol will reimburse this payment if the claim is rati\ufb01ed.", "doc_id": "ce20ff79-db06-4103-b701-cf3b202a1dca", "embedding": null, "doc_hash": "af6f7919913cbcf047529621bdfe78985c6150f173991dff26be46f27e21b0e8", "extra_info": {"page_label": "6"}, "node_info": {"start": 2952, "end": 4198}, "relationships": {"1": "ec90b780-21f8-40a1-9dc3-47b76b55077b", "2": "9e9fa8c6-dc0c-4299-8679-63ee3005ee72"}}, "__type__": "1"}, "78c6a6a1-b17c-464a-9859-f91e1826651f": {"__data__": {"text": "/d.sc/a.sc/t.sc/a.sc /s.sc/t.sc/a.sc/k.sc/i.sc/n.sc/g.sc 7\nFigure 3: Flowchart of the steps in the claims process.\nA claim will include the following \ufb01elds:\n1. The product for which the incorrect data appeared\n2. The time interval when the incorrect data appeared. This interval should be\nrelatively short, e.g., 1second.\n3. The results of a HUMAN protocol task that determines the truth of the claim\nand which publishers were at fault. Pyth network developers will provide a\ngithub repository that allows anyone to quickly run the necessary HUMAN\ntask and combine their results in a veri\ufb01able way.\nThe HUMAN task will ask a random sample of workers to report several pieces\nof off-chain information:\n1. The maximum and minimum price for the product during the time interval\nin question on a \ufb01xed set of reference exchanges. These reference exchanges\nwill be selected in advance per-product by Pyth protocol governance.\n2. The maximum and minimum aggregate price and maximum con\ufb01dence inter-\nval during the time in question.\n3. The maximum and minimum price per publisher and maximum con\ufb01dence\ninterval during the time in question.\nThe claim will be successful if ( 1) the price feed published an aggregate price dur-\ning the claim interval, and ( 2) the published price, incorporating any uncertainty\nprovided by the con\ufb01dence interval, disagrees with the reference prices. The agree-\nment algorithm operates on two price ranges. The Pyth network price range extends\nfrom the minimum aggregate price minus 3con\ufb01dence intervals to the maximum\naggregate price plus 3con\ufb01dence intervals. The reference price range extends from\nthe minimum to the maximum reference price. The algorithm will deem the claim\nsuccessful if these two ranges do not overlap; this check indicates that the refer-\nence price was highly improbable according to the Pyth network. If the claim is\nsuccessful, the algorithm will additionally identify a set of at-fault publishers. The\nalgorithm will judge publishers using the same range overlap criterion, except with", "doc_id": "78c6a6a1-b17c-464a-9859-f91e1826651f", "embedding": null, "doc_hash": "3f02bd9217aa1dcc7b8602d4cebbde00c3b4fb8b1c978027f1aba0b9c76e0b1a", "extra_info": {"page_label": "7"}, "node_info": {"start": 0, "end": 2037}, "relationships": {"1": "395afdac-f424-4295-9066-ef4ca496a153"}}, "__type__": "1"}, "dfb0c32c-f098-47fe-9f04-141f1a68a25b": {"__data__": {"text": "/r.sc/e.sc/w.sc/a.sc/r.sc/d.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc 8\ntheir quoted price and con\ufb01dence instead of the aggregate. This computation re-\nsults in ( 1) a yes/no decision on whether the claim is successful and ( 2), if yes, a list\nof publishers who are at fault.\nThe HUMAN task will be con\ufb01gured to increase the dif\ufb01culty for an adversary\nto in\ufb02uence the process. Speci\ufb01cally, the task will be instantaneously distributed\nto judges across the globe and will require the judges to have a certain level of\nagreement before the answer is accepted. HUMAN protocol will sign and post\nthe results of this task on-chain, where PYTH token-holders can verify them in the\nrati\ufb01cation step.\nThis portion of the claims process will be implemented in a software package that\nanyone can run. The software package will ( 1) instantiate the necessary HUMAN\ntasks with the appropriate parameters, ( 2) gather the results from users of the HU-\nMAN protocol, and ( 3) run the algorithm described above to determine the success\nof the claim. Users of the package can directly submit its output for rati\ufb01cation.\nFinally, PYTH token-holders will vote to ratify the output of the algorithm. The\ntoken-holders should check the on-chain results of the HUMAN task, then run\ntheir own instance of the claims software against the results. They should also not\nbe aware of any circumstances indicating that anyone is trying to manipulate the\nclaims process, for example, by broadcasting a bribe to HUMAN judges. (Token-\nholders are likely to be aware of a bribe offer if one exists, due to the con\ufb01guration\nof the HUMAN task.) If the results are genuine, the token-holders should vote\nto ratify the claim. If rati\ufb01ed, the protocol will slash the stakes of the product\u2019s\ndelegators and any at-fault publishers. The protocol will distribute the slashed\ntokens to the consumers who paid data fees.\nFrom the perspective of the on-chain implementation of the Pyth protocol, the\nclaims process only has two steps. The \ufb01rst step is submitting a claim, and the sec-\nond step is ratifying it. No off-chain computation or discussion is strictly required\nto run either step, but the incentives encourage these off-chain activities. For exam-\nple, a user could elect to \ufb01le a claim without running the HUMAN task. However,\nPYTH token-holders are unlikely to ratify this claim. Similarly, PYTH token-holders\ncould vote to reject every claim. However, they are strongly incentivized to accept\nclaims when the results of the HUMAN task indicate that the claim should be suc-\ncessful.\n/four.taboldstyle /r.sc/e.sc/w.sc/a.sc/r.sc/d.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc\nThe reward distribution mechanism will determine the share of the reward pool\nearned by each publisher. As a reminder, the data staking mechanism will distribute\na portion of the data fees per product into a reward pool for that product. This\nportion initially will be 20% but may be adjusted by governance. The reward pool\nmay additionally include bonus rewards to bootstrap the protocol (discussed in\nfurther detail below).\nThe reward distribution mechanism is designed to achieve the following goals:\n1.Preferentially reward higher-quality publishers . Publishers are not uniform,\nand some have access to more accurate or timely", "doc_id": "dfb0c32c-f098-47fe-9f04-141f1a68a25b", "embedding": null, "doc_hash": "1734ba15d810a5c23d343085474ef07d6f7c1f4b7a52fe9d2ae187474c5357d6", "extra_info": {"page_label": "8"}, "node_info": {"start": 0, "end": 3316}, "relationships": {"1": "497414cb-33fa-4e5f-ad0a-6a1550e444b9", "3": "a82882a4-37f4-4f61-9463-a1ecc624ee2f"}}, "__type__": "1"}, "a82882a4-37f4-4f61-9463-a1ecc624ee2f": {"__data__": {"text": "reward distribution mechanism will determine the share of the reward pool\nearned by each publisher. As a reminder, the data staking mechanism will distribute\na portion of the data fees per product into a reward pool for that product. This\nportion initially will be 20% but may be adjusted by governance. The reward pool\nmay additionally include bonus rewards to bootstrap the protocol (discussed in\nfurther detail below).\nThe reward distribution mechanism is designed to achieve the following goals:\n1.Preferentially reward higher-quality publishers . Publishers are not uniform,\nand some have access to more accurate or timely pricing information than\nothers. The reward system should preferentially reward these publishers so\nthat the best publishers are incentivized to contribute to the protocol.\n2.Prevent bad actors from earning rewards . Publishers may attempt to exploit\nthe system for personal gain. The reward mechanism must penalize bad actors\nto disincentivize them from participating in the protocol.\n3.Encourage honest reporting of private information . Publishers typically have\nprivate pricing information, such as their recent trades on various exchanges.\nThe incentives should encourage publishers to honestly report prices using", "doc_id": "a82882a4-37f4-4f61-9463-a1ecc624ee2f", "embedding": null, "doc_hash": "433dfa5671d8d6c5485a7dcb37c01823730f6d7c7f6d5394dcf9536d45fe4309", "extra_info": {"page_label": "8"}, "node_info": {"start": 2689, "end": 3936}, "relationships": {"1": "497414cb-33fa-4e5f-ad0a-6a1550e444b9", "2": "dfb0c32c-f098-47fe-9f04-141f1a68a25b"}}, "__type__": "1"}, "c43bd1fd-9b19-4f5d-b652-5aadd223d59f": {"__data__": {"text": "/r.sc/e.sc/w.sc/a.sc/r.sc/d.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc 9\nthis private information, as the combination of publishers\u2019 honest reports will\nresult in the most accurate aggregate price.\nExisting oracle mechanisms fail to accomplish these three goals. Other oracle\nmechanisms reward publishers for agreeing, i.e., reporting the same price. However,\nrewarding agreement creates a perverse incentive for publishers to misreport their\nprivate price information. Imagine a publisher thinks the price is currently $ 110\nbut notices that the aggregate price on the previous slot was $ 100. The publisher\nknows that the price is unlikely to move by $ 10in a single slot, so they can infer\nthat the aggregate price on this slot is also likely to be around $ 100. The publisher\nmay choose to maximize agreement by reporting a price close to $ 100 instead of\ntheir actual estimate of $ 110. Formalizing this argument shows that rewarding\nagreement incentivizes publishers to report their best estimate of what everyone else\nwill report and not their private price.\nThe second problem is that agreement cannot separate bad actors from good ac-\ntors. Prices are often stable for periods of time, so the aggregate price from the\nprevious Solana slot is a reasonable estimate of the current price. Therefore, if\nthe protocol rewards agreement, bad actors can trivially earn rewards by replay-\ning aggregate prices with a delay. The protocol also should not simply penalize\ndisagreement because honest publishers will occasionally diverge from the actual\nprice.\nThese problems occur because existing oracle mechanisms are designed for the\ncase where every publisher has access to the same information. In these cases,\nagreement suf\ufb01ces to validate that the publishers have reported it correctly, as there\nis no reason to expect honest publishers to disagree. In Pyth\u2019s case, publishers have\nprivate information, and are not expected to report the exact same price. There are\nreal-world circumstances in which the prices on exchanges disagree and the oracle\nshould re\ufb02ect those circumstances.\nThis whitepaper proposes a new oracle mechanism for the private information\nsetting based on a critical insight: publishers should be rewarded for sharing new\ninformation, i.e., changes to the current price. The mechanism measures new in-\nformation by calculating how well a price series predicts future changes in the\naggregate price. This mechanism is also dif\ufb01cult for bad actors to exploit under the\nassumption that they cannot easily predict future prices from historical prices.\n/four.taboldstyle./one.taboldstyle Score Computation\nThe reward distribution mechanism will divide the reward pool for a product\namongst publishers in proportion to three quantities:\n1. The publisher\u2019s stake-weight s, as determined by the data staking mechanism.\nThis number is between 0and 1.\n2. A quality score qmeasuring how well the publisher\u2019s price series predicts\nfuture price changes. This score lies between - 1and 1, and a positive score\nimplies some predictive power.\n3. The calibration cof the publisher\u2019s con\ufb01dence intervals. This quantity is a\nnumber between 0and 1.\nThe mechanism will distribute rewards at the end of each epoch. The on-chain\nprogram will estimate qand cfor each publisher during the epoch. At the end of\nthe epoch, each publisher earns a share of the reward pool in proportion to s\u0002q\u0002c.\nIf this quantity is negative, the mechanism will slash the publisher\u2019s stake by the\ncorresponding amount.", "doc_id": "c43bd1fd-9b19-4f5d-b652-5aadd223d59f", "embedding": null, "doc_hash": "2801853c10a516866a92bf0fea5b33f13c8f8835bb198de3f19ed000d589a04c", "extra_info": {"page_label": "9"}, "node_info": {"start": 0, "end": 3519}, "relationships": {"1": "dbbe853b-db39-4fe2-92c2-fc1b7102dc72"}}, "__type__": "1"}, "fda9e915-ef8b-40e6-bd59-c2873b369545": {"__data__": {"text": "/r.sc/e.sc/w.sc/a.sc/r.sc/d.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc 10\nFigure 4: Visualization of the quality score for two publishers in a historical data sample. The\nleft graph is a scatterplot of the predicted and actual price changes. The tighter the\nlinear relationship between these quantities, the higher the quality score. The axes\nof the right graph correspond to the two non-bias features of the regression model\nand the color denotes the actual price change. A smooth color gradient indicates a\nhigh quality score. The top publisher obtains a higher score than the bottom one\nin this sample.\n/four.taboldstyle./one.taboldstyle./one.taboldstyle Quality Score\nThe quality score measures how well a publisher\u2019s price series predicts future\nchanges in the aggregate price. The mechanism will compute this score by train-\ning an online regression model that predicts the future price from several features\nof the publisher\u2019s price series. Let pt,stbe the publisher\u2019s price and con\ufb01dence\non slot t, and let \u00afptbe the aggregate price on that slot. That is, the aggregation\nalgorithm computes \u00afptfrom all of the publishers\u2019 prices pt. On slot t, the regression\nmodel performs the following set of updates:\nft [pt\u0000\u00afpt\u00001,pt\u0000pt\u00001, 1]\n\u02c6pt wT\nt\u00001ft+\u00afpt\u00001\nwt clip(a\nst(\u02c6pt\u0000\u00afpt)ft,\u00000.1, 0.1 )\nIn the above equations, \u02c6ptrepresents a prediction for the aggregate price on the\ncurrent timestep. A linear regression model computes this prediction from two\nchange-in-price features that compare the publisher\u2019s current price ptto their own\nprice and the aggregate from the previous slot. wtrepresents the regression model\u2019s\nweights. After each prediction, the \ufb01nal equation updates these weights using a\nstandard clipped gradient update.\nThe quality score qis the product of two terms. The \ufb01rst term is the correlation\nbetween the predicted price \u02c6ptand the aggregate price \u00afptover the entire epoch,\nand the second term is the fraction of slots in which the publisher contributed\na price. The correlation measures how well the predicted prices agree with the\naggregate. If the predictions are perfect, the correlation is 1. If the predictions are\nrandom, the correlation is 0. If (somehow) the predictions are worse than random,\nthe correlation is negative. Honest publishers are unlikely to encounter this third\ncase, but it guards against adversarial behavior (see Discussion, below).", "doc_id": "fda9e915-ef8b-40e6-bd59-c2873b369545", "embedding": null, "doc_hash": "2eb960d08f1e8bec2a9025d1e10ef50f0f104b9e9f68044fca30e069d580d370", "extra_info": {"page_label": "10"}, "node_info": {"start": 0, "end": 2402}, "relationships": {"1": "dc735726-178c-4cf1-8662-3edbb0475973"}}, "__type__": "1"}, "0c09c82c-3870-4881-a970-62550b020895": {"__data__": {"text": "/r.sc/e.sc/w.sc/a.sc/r.sc/d.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc 11\nThe quality score proposed here permits multiple variations. First, it could pre-\ndict price changes more than 1slot ahead in the future, which are presumably\nharder to predict. Second, it could incorporate additional features. For example,\nsome exchanges often have minor but persistent price differences. This mechanism\ncould avoid punishing such price differences if it included a feature that tracks them.\nThe Pyth network developers have experimented with this mechanism on historical\ndata, and those experiments suggest that the version presented here produces rea-\nsonable results. However, the general approach is \ufb02exible and can be tuned in the\nfuture.\n/four.taboldstyle./one.taboldstyle./two.taboldstyle Calibration Score\nThe calibration score cmeasures whether the publisher\u2019s con\ufb01dence interval ac-\ncurately represents their uncertainty. The score interprets the con\ufb01dence interval\nas the standard error of a Laplace distribution within which the publisher expects\nto \ufb01nd the aggregate price. (The Laplace distribution is a heavy-tailed distribu-\ntion that better represents the actual distribution of prices relative to the normal\ndistribution.) The score uses a simple frequency test to measure how closely the\naggregate price follows the implied distribution. Speci\ufb01cally, it computes a z-score\nby taking the difference between the aggregate and prediction, then normalizing by\nthe publisher\u2019s con\ufb01dence interval. The resulting z-score is then binned to produce\na histogram; the z-score thresholds for each bin are chosen such that each bin has\nequal probability under the standard Laplace distribution. This procedure applied\nto a perfect publisher should produce a uniform histogram. The calibration score\nis therefore de\ufb01ned as one minus the earth-mover distance between the publisher\u2019s\nhistogram and uniform.\nNote that the calibration score does not bene\ufb01t publishers for producing tighter\ncon\ufb01dence intervals. The quality score already solves this problem: publishers\nwith tighter con\ufb01dence intervals should also have more accurate price predictions.\nInstead, the calibration score ccaptures whether the reported con\ufb01dence interval\ncorresponds to the publisher\u2019s \"true\" con\ufb01dence.\n/four.taboldstyle./two.taboldstyle Discussion\nThis reward distribution mechanism has many bene\ufb01cial properties that align with\nthe goals above:\n1. The mechanism assigns higher rewards to publishers with more predictive\nprice series and better-calibrated con\ufb01dence intervals. These publishers are\nalso likely to attract a higher percentage of the stake-weight. Consequently,\nthese publishers will earn a larger share of the reward pool. The mechanism\nthereby incentivizes the best publishers to participate in the protocol.\n2. The properties of the correlation coef\ufb01cient reduce the likelihood that bad ac-\ntors will earn rewards in the system. This analysis requires two assumptions:\n(1) future prices are hard to predict from historical prices, and ( 2) the Pyth\naggregate price tracks the actual price. The \ufb01rst assumption is the ef\ufb01cient\nmarket hypothesis, which is broadly true on the small timescales required.\nThe second assumption should be valid because the aggregation algorithm is\nrobust; thus, an attacker has limited ability to manipulate the Pyth aggregate\nprice away from the actual price. Under these two assumptions, an adversary\nwith access to only historical Pyth data cannot earn rewards as a Pyth pub-\nlisher: their predictions \u02c6ptwill be random, so their correlation", "doc_id": "0c09c82c-3870-4881-a970-62550b020895", "embedding": null, "doc_hash": "f85838d63c62472b6aaad79d4d3d7ca1b3d3624a2d610233e2e9847c4d6eaf56", "extra_info": {"page_label": "11"}, "node_info": {"start": 0, "end": 3583}, "relationships": {"1": "091bce92-cf5b-4ebc-8c3f-78711a002e0d", "3": "db0fdb60-c128-4c26-ad59-632d2f5c0bfb"}}, "__type__": "1"}, "db0fdb60-c128-4c26-ad59-632d2f5c0bfb": {"__data__": {"text": "the correlation coef\ufb01cient reduce the likelihood that bad ac-\ntors will earn rewards in the system. This analysis requires two assumptions:\n(1) future prices are hard to predict from historical prices, and ( 2) the Pyth\naggregate price tracks the actual price. The \ufb01rst assumption is the ef\ufb01cient\nmarket hypothesis, which is broadly true on the small timescales required.\nThe second assumption should be valid because the aggregation algorithm is\nrobust; thus, an attacker has limited ability to manipulate the Pyth aggregate\nprice away from the actual price. Under these two assumptions, an adversary\nwith access to only historical Pyth data cannot earn rewards as a Pyth pub-\nlisher: their predictions \u02c6ptwill be random, so their correlation qwill also be\na random variable with 0expectation. The reward/penalty for each publisher\nis proportional to q, so their expected reward in each epoch is also 0. Fur-\nthermore, the reward mechanism penalizes publishers with negative quality\nscores by slashing their stake, such that the expected reward over multiple", "doc_id": "db0fdb60-c128-4c26-ad59-632d2f5c0bfb", "embedding": null, "doc_hash": "4d18a95ccc323b91f9e59a56192e657fbbedca5fc4b08d4af5e6ba6c2eb20b72", "extra_info": {"page_label": "11"}, "node_info": {"start": 2840, "end": 3899}, "relationships": {"1": "091bce92-cf5b-4ebc-8c3f-78711a002e0d", "2": "0c09c82c-3870-4881-a970-62550b020895"}}, "__type__": "1"}, "3a7b4754-e785-419c-b701-5ac6bb7eba09": {"__data__": {"text": "/g.sc/o.sc/v.sc/e.sc/r.sc/n.sc/a.sc/n.sc/c.sc/e.sc 12\nepochs is also zero. The penalty is indispensable: otherwise, bad actors could\nplay the game over multiple epochs, and their quality score would be positive\nthrough sheer chance in some epochs. The penalty is designed so that losses\nin other epochs balance out rewards from these epochs.\n3. The adaptive nature of the predictions eliminates the primary incentives for\ndishonesty. Publishers no longer have to agree with the aggregate as long as\nthe prediction computed by the regression agrees with the aggregate.\nThis reward mechanism does have some minor weaknesses. One weakness is that\nan attacker could copy a publisher\u2019s price within the same slot. This attack would\nrequire the attacker to read a publisher\u2019s price update and submit their own price\nupdate within the Solana slot time. The protocol could defend against this attack\nusing a commit-reveal system for publisher price updates. A second weakness\nis that the mechanism encourages publishers to submit predictions of future prices,\nwhich may not agree with the actual price. This attack seems unlikely: if a publisher\ncould predict future prices, it would be more pro\ufb01table to trade on their predictions\ninstead of publishing them. It also exposes the publisher to getting slashed in a data\nstaking claim.\n/five.taboldstyle /g.sc/o.sc/v.sc/e.sc/r.sc/n.sc/a.sc/n.sc/c.sc/e.sc\nThe Pyth Data Association will initially govern the protocol while it is under devel-\nopment. Over time, the Association will transfer full control of the protocol to an\non-chain governance mechanism. Once the transfer occurs, all protocol governance\nwill be on-chain. However, on-chain governance systems have various failings \u2014\ne.g., borrowing coins to vote \u2014 that do not have effective technical solutions. There-\nfore, the general design philosophy is to reduce the necessity for governance input.\nThe on-chain governance mechanism will approve or reject proposals using a\ncoin-voting system. Anyone with a minimum quantity of staked PYTH tokens will\nbe able to make a governance proposal. PYTH stakers will then be allowed to\nvote on these proposals. They will also be able to delegate their votes to others.\nGovernance votes will run for 2weeks from the proposal date, and only tokens\nstaked in prior epochs will be allowed to vote. Users will be permitted to vote\nwith PYTH tokens that are staked toward other applications (e.g., data staking).\nAdditionally, some users currently own locked PYTH tokens, which will also be\npermitted to vote.\nOn-chain governance is expected to be responsible for taking the following ac-\ntions:\n\u000fApproving the types of tokens that may be used for data fees.\n\u000fDetermining which products are listed on Pyth and their reference data (e.g.,\nnumber of decimal places in the price, reference exchanges).\n\u000fDetermining the share of data fees allocated to publishers, delegators, and\nother uses.\n\u000fApproving software updates to the on-chain program.\n\u000fDetermining the number of PYTH tokens that publishers must stake.\n\u000fDetermining the number of products that a delegator can back per staked\nPYTH token.\n\u000fEnabling claims to be \ufb01led against a product. Governance should take this\naction once the product has enough publishers to produce a robust price feed.\n\u000fPermissioning publishers to provide price feeds.", "doc_id": "3a7b4754-e785-419c-b701-5ac6bb7eba09", "embedding": null, "doc_hash": "93bcc736934bd3048ef522f4b5f63392af1b942d5ef3bbe820a479b6d585b01c", "extra_info": {"page_label": "12"}, "node_info": {"start": 0, "end": 3329}, "relationships": {"1": "e7f96c59-7448-428f-a058-d7554f958759"}}, "__type__": "1"}, "37721021-280e-434f-b167-3d7d12f73c7e": {"__data__": {"text": "/i.sc/n.sc/c.sc/e.sc/n.sc/t.sc/i.sc/v.sc/e.sc/s.sc 13\n/six.taboldstyle /i.sc/n.sc/c.sc/e.sc/n.sc/t.sc/i.sc/v.sc/e.sc/s.sc\nThis section summarizes the incentives for the various participants in the proposed\nprotocol.\nPublishers are incentivized to publish accurate and timely prices by the data stak-\ning and reward distribution mechanisms. Participants must stake PYTH tokens to\nbecome publishers. The data staking mechanism can slash their stake if ( 1) they ever\npublish a price far from the reference price and ( 2) that price subsequently causes\na problem with the oracle\u2019s price feed. This possible penalty encourages publishers\nto publish prices close to the overall market. The reward distribution mechanism\nalso preferentially rewards publishers whose prices predict future changes in the\naggregate price.\nPublishers are incentivized to participate in the protocol to earn a share of the\nrewards. Publishers earn a share of the data fees for the products they price. The\ndata fees for a product will likely grow in proportion to consumer usage of the\nprice feed, while the capital required (the staked PYTH tokens) and publishing cost\nremain \ufb01xed. Popular products with few publishers could produce an attractive\nlevel of payments.\nThe primary attacks that publishers could perform are ( 1) attempting to manip-\nulate the aggregate price and ( 2) attempting to earn rewards without contributing\nnew pricing information. Delegators will guard against the \ufb01rst attack by setting\neach publisher\u2019s stake weights to limit their in\ufb02uence on the aggregate price. The\nprotocol incentivizes the delegators to set these weights such that no single pub-\nlisher or small group can manipulate the price. The rewards mechanism will guard\nagainst the second attack by only rewarding publishers whose price series predict\nfuture price changes.\nConsumers are incentivized to pay data fees for two reasons. First, data fees en-\nable applications to reduce the risk of using Pyth price feeds. Users of applications\nare highly risk-sensitive and will make usage decisions accordingly. Second, paying\ndata fees attracts more publishers to the product, which improves the robustness of\nthe price feed.\nIt is possible that consumers consider paying data fees and then attack the system\nto trigger an invalid payout. The claims process is carefully designed to reduce the\nlikelihood of this outcome.\nDelegators are incentivized to participate in the protocol to earn data fees. Del-\negators will initially earn attractive payments, but competition between them will\nreduce the payments over time as the market becomes more ef\ufb01cient. In the long\nrun, the payments earned by delegators will re\ufb02ect the activity\u2019s inherent risks and\nthe broader investment climate.\nDelegators also have a secondary role, which is to set the stake-weights of pub-\nlishers. The protocol incentivizes delegators to set these weights in a way that max-\nimizes the robustness of the price feed because delegators risk losing their stake if\nthe aggregate price feed is incorrect.\n/seven.taboldstyle /t.sc/o.sc/k.sc/e.sc/n.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc\nThere are 10,000,000,000PYTH tokens and this total supply will not increase. Fur-\nthermore, 85% of the tokens will initially be contractually locked. These tokens will\nunlock monthly over 7years with an initial 1-year cliff. This schedule is designed\nto produce a gradual increase the", "doc_id": "37721021-280e-434f-b167-3d7d12f73c7e", "embedding": null, "doc_hash": "de16d9a30fb1729c96f0d9ae7c29552c4097b5d2b3d0b846a19c81f3a82abddc", "extra_info": {"page_label": "13"}, "node_info": {"start": 0, "end": 3428}, "relationships": {"1": "1c7f0335-a0e9-4818-ac92-c0afdbe56d82", "3": "2bab7572-b189-450e-8c30-045a78763a52"}}, "__type__": "1"}, "2bab7572-b189-450e-8c30-045a78763a52": {"__data__": {"text": "these weights in a way that max-\nimizes the robustness of the price feed because delegators risk losing their stake if\nthe aggregate price feed is incorrect.\n/seven.taboldstyle /t.sc/o.sc/k.sc/e.sc/n.sc /d.sc/i.sc/s.sc/t.sc/r.sc/i.sc/b.sc/u.sc/t.sc/i.sc/o.sc/n.sc\nThere are 10,000,000,000PYTH tokens and this total supply will not increase. Fur-\nthermore, 85% of the tokens will initially be contractually locked. These tokens will\nunlock monthly over 7years with an initial 1-year cliff. This schedule is designed\nto produce a gradual increase the unlocked token supply over time. The remain-\ning15% of PYTH tokens will initially be unlocked. The supply of both locked and\nunlocked tokens will be allocated according to the categories shown in Table 1.", "doc_id": "2bab7572-b189-450e-8c30-045a78763a52", "embedding": null, "doc_hash": "e9b29bb693bd3457725d17930daef29d5aaec606d9ca176d04bc96000dccfd3f", "extra_info": {"page_label": "13"}, "node_info": {"start": 2880, "end": 3633}, "relationships": {"1": "1c7f0335-a0e9-4818-ac92-c0afdbe56d82", "2": "37721021-280e-434f-b167-3d7d12f73c7e"}}, "__type__": "1"}, "d2c4ead3-34bd-4333-b2c4-461303d6fb05": {"__data__": {"text": "/c.sc/o.sc/n.sc/c.sc/l.sc/u.sc/s.sc/i.sc/o.sc/n.sc 14\nUnlocked Locked Total\nOn-chain Rewards 8% 14% 22%\nEcosystem Participation 5% 28% 33%\nTeam and Advisors 25% 25%\nLaunch Partners 2% 8% 10%\nPrivate Sale 10% 10%\nTable 1: Allocation of locked and unlocked PYTH tokens. Locked tokens unlock monthly\nover 7years with an initial 1-year cliff.\n/seven.taboldstyle./one.taboldstyle Bootstrapping rewards\nThe Pyth protocol will likely provide additional incentives to early participants in\nthe protocol. Speci\ufb01cally, the protocol faces a cold-start problem for new products.\nThese products have neither publishers nor consumers to pay data fees. However,\npublishers have no incentive to price a new product without data fees. One way\nfor the protocol to address this problem is to incentivize early publishers for new\nproducts.\nVarious incentive systems could be applied to solve the cold-start problem. For\nexample, the protocol could add bonus tokens to the reward pools for new prod-\nucts. The protocol could initially take these tokens from a preallocated reward\npool or perhaps a portion of the data fees for mature products. The protocol could\ndistribute these bonus tokens in various ways, for example, to re\ufb02ect the relative\ndif\ufb01culty of sourcing different types of data. The Association will reserve a substan-\ntial portion ( 22%) of the total PYTH token supply for distribution in such incentive\nsystems.\nNew products will also go through two stages. When the product is \ufb01rst added,\nthe protocol will not permit claims against the product. When a product only has\na small number of publishers, the price feed is not suf\ufb01ciently robust, as each pub-\nlisher has substantial in\ufb02uence over the aggregate price. Once the product has a\nsuf\ufb01cient number of publishers, governance will vote to enable claims. However,\nthe protocol will allow consumers to pay data fees on products whose claims are\ncurrently disabled as a signaling mechanism. For example, a protocol that wanted\ntheir governance token listed could use this mechanism to provide an added incen-\ntive for publishers.\n/eight.taboldstyle /c.sc/o.sc/n.sc/c.sc/l.sc/u.sc/s.sc/i.sc/o.sc/n.sc\nThis whitepaper proposes an oracle protocol to make accurate, high-resolution \ufb01-\nnancial market data easily accessible on-chain. The protocol is designed to be a self-\nsustaining decentralized network that coordinates data publishers and consumers.\nA critical element of the design is a data staking mechanism for consumers that dis-\ntributes a share of data fees to publishers. The protocol is also designed to attract\npublishers with high-quality pricing data. The mechanisms help prevent malicious\nattackers from manipulating the protocol to their bene\ufb01t in various ways, such as\nmanipulating the price.", "doc_id": "d2c4ead3-34bd-4333-b2c4-461303d6fb05", "embedding": null, "doc_hash": "2309f88e37698671bb7b6e4347e01d0523075efd3cf01bec81df95163a445ba3", "extra_info": {"page_label": "14"}, "node_info": {"start": 0, "end": 2752}, "relationships": {"1": "76ebd27e-30cc-4ac6-822c-1d09cf20f1fb"}}, "__type__": "1"}}}